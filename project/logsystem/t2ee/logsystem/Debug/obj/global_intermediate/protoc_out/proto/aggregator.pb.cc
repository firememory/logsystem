// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "aggregator.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#ifdef _MSC_VER
# pragma warning(push)
# pragma warning(disable: 4244 4267 4127)
#endif /* _MSC_VER */
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#ifdef _MSC_VER
# pragma warning(default: 4244 4267 4127)
# pragma warning(pop)
# pragma warning(disable: 4100)
#endif /* _MSC_VER */
// @@protoc_insertion_point(includes)

namespace aggregator {

void protobuf_ShutdownFile_aggregator_2eproto() {
  delete FileID::default_instance_;
  delete CheckSumRequest::default_instance_;
  delete CheckSumResponse::default_instance_;
  delete LogRequest::default_instance_;
  delete LogResponse::default_instance_;
  delete FileRequest::default_instance_;
  delete FileRequest_File::default_instance_;
  delete FileResponse::default_instance_;
  delete FileResponse_File::default_instance_;
  delete FileDataRequest::default_instance_;
  delete FileDataRequest_FileData::default_instance_;
  delete FileDataResponse::default_instance_;
  delete FileDataResponse_FileData::default_instance_;
  delete CollectorFileRequest::default_instance_;
  delete CollectorFileResponse::default_instance_;
  delete CollectorFileResponse_File::default_instance_;
  delete CollectRuleRequest::default_instance_;
  delete CollectRuleResponse::default_instance_;
  delete CollectRuleResponse_Rule::default_instance_;
  delete ConfigRequest::default_instance_;
  delete ConfigResponse::default_instance_;
  delete ConfigResponse_Time::default_instance_;
  delete LogonRequest::default_instance_;
  delete LogonResponse::default_instance_;
  delete LogoutRequest::default_instance_;
  delete KeepAliveRequest::default_instance_;
  delete KeepAliveResponse::default_instance_;
  delete InstructResponse::default_instance_;
  delete TransID::default_instance_;
  delete CollectorRequest::default_instance_;
  delete AggregatorResponse::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_aggregator_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;
#else
void protobuf_AddDesc_aggregator_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;
#endif
  FileID::default_instance_ = new FileID();
  CheckSumRequest::default_instance_ = new CheckSumRequest();
  CheckSumResponse::default_instance_ = new CheckSumResponse();
  LogRequest::default_instance_ = new LogRequest();
  LogResponse::default_instance_ = new LogResponse();
  FileRequest::default_instance_ = new FileRequest();
  FileRequest_File::default_instance_ = new FileRequest_File();
  FileResponse::default_instance_ = new FileResponse();
  FileResponse_File::default_instance_ = new FileResponse_File();
  FileDataRequest::default_instance_ = new FileDataRequest();
  FileDataRequest_FileData::default_instance_ = new FileDataRequest_FileData();
  FileDataResponse::default_instance_ = new FileDataResponse();
  FileDataResponse_FileData::default_instance_ = new FileDataResponse_FileData();
  CollectorFileRequest::default_instance_ = new CollectorFileRequest();
  CollectorFileResponse::default_instance_ = new CollectorFileResponse();
  CollectorFileResponse_File::default_instance_ = new CollectorFileResponse_File();
  CollectRuleRequest::default_instance_ = new CollectRuleRequest();
  CollectRuleResponse::default_instance_ = new CollectRuleResponse();
  CollectRuleResponse_Rule::default_instance_ = new CollectRuleResponse_Rule();
  ConfigRequest::default_instance_ = new ConfigRequest();
  ConfigResponse::default_instance_ = new ConfigResponse();
  ConfigResponse_Time::default_instance_ = new ConfigResponse_Time();
  LogonRequest::default_instance_ = new LogonRequest();
  LogonResponse::default_instance_ = new LogonResponse();
  LogoutRequest::default_instance_ = new LogoutRequest();
  KeepAliveRequest::default_instance_ = new KeepAliveRequest();
  KeepAliveResponse::default_instance_ = new KeepAliveResponse();
  InstructResponse::default_instance_ = new InstructResponse();
  TransID::default_instance_ = new TransID();
  CollectorRequest::default_instance_ = new CollectorRequest();
  AggregatorResponse::default_instance_ = new AggregatorResponse();
  FileID::default_instance_->InitAsDefaultInstance();
  CheckSumRequest::default_instance_->InitAsDefaultInstance();
  CheckSumResponse::default_instance_->InitAsDefaultInstance();
  LogRequest::default_instance_->InitAsDefaultInstance();
  LogResponse::default_instance_->InitAsDefaultInstance();
  FileRequest::default_instance_->InitAsDefaultInstance();
  FileRequest_File::default_instance_->InitAsDefaultInstance();
  FileResponse::default_instance_->InitAsDefaultInstance();
  FileResponse_File::default_instance_->InitAsDefaultInstance();
  FileDataRequest::default_instance_->InitAsDefaultInstance();
  FileDataRequest_FileData::default_instance_->InitAsDefaultInstance();
  FileDataResponse::default_instance_->InitAsDefaultInstance();
  FileDataResponse_FileData::default_instance_->InitAsDefaultInstance();
  CollectorFileRequest::default_instance_->InitAsDefaultInstance();
  CollectorFileResponse::default_instance_->InitAsDefaultInstance();
  CollectorFileResponse_File::default_instance_->InitAsDefaultInstance();
  CollectRuleRequest::default_instance_->InitAsDefaultInstance();
  CollectRuleResponse::default_instance_->InitAsDefaultInstance();
  CollectRuleResponse_Rule::default_instance_->InitAsDefaultInstance();
  ConfigRequest::default_instance_->InitAsDefaultInstance();
  ConfigResponse::default_instance_->InitAsDefaultInstance();
  ConfigResponse_Time::default_instance_->InitAsDefaultInstance();
  LogonRequest::default_instance_->InitAsDefaultInstance();
  LogonResponse::default_instance_->InitAsDefaultInstance();
  LogoutRequest::default_instance_->InitAsDefaultInstance();
  KeepAliveRequest::default_instance_->InitAsDefaultInstance();
  KeepAliveResponse::default_instance_->InitAsDefaultInstance();
  InstructResponse::default_instance_->InitAsDefaultInstance();
  TransID::default_instance_->InitAsDefaultInstance();
  CollectorRequest::default_instance_->InitAsDefaultInstance();
  AggregatorResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_aggregator_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_aggregator_2eproto_once_);
void protobuf_AddDesc_aggregator_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_aggregator_2eproto_once_,
                 &protobuf_AddDesc_aggregator_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_aggregator_2eproto {
  StaticDescriptorInitializer_aggregator_2eproto() {
    protobuf_AddDesc_aggregator_2eproto();
  }
} static_descriptor_initializer_aggregator_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int FileID::kIdFieldNumber;
#endif  // !_MSC_VER

FileID::FileID()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FileID::InitAsDefaultInstance() {
}

FileID::FileID(const FileID& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FileID::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileID::~FileID() {
  SharedDtor();
}

void FileID::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FileID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileID& FileID::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

FileID* FileID::default_instance_ = NULL;

FileID* FileID::New() const {
  return new FileID;
}

void FileID::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FileID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }
  
}

int FileID::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileID::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileID*>(&from));
}

void FileID::MergeFrom(const FileID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
}

void FileID::CopyFrom(const FileID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void FileID::Swap(FileID* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FileID::GetTypeName() const {
  return "aggregator.FileID";
}


// ===================================================================

#ifndef _MSC_VER
const int CheckSumRequest::kIdFieldNumber;
const int CheckSumRequest::kFbCsPosFieldNumber;
const int CheckSumRequest::kFbCsCountFieldNumber;
#endif  // !_MSC_VER

CheckSumRequest::CheckSumRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CheckSumRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_ = const_cast< ::aggregator::FileID*>(
      ::aggregator::FileID::internal_default_instance());
#else
  id_ = const_cast< ::aggregator::FileID*>(&::aggregator::FileID::default_instance());
#endif
}

CheckSumRequest::CheckSumRequest(const CheckSumRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CheckSumRequest::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  fb_cs_pos_ = 0u;
  fb_cs_count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckSumRequest::~CheckSumRequest() {
  SharedDtor();
}

void CheckSumRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_;
  }
}

void CheckSumRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CheckSumRequest& CheckSumRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

CheckSumRequest* CheckSumRequest::default_instance_ = NULL;

CheckSumRequest* CheckSumRequest::New() const {
  return new CheckSumRequest;
}

void CheckSumRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != NULL) id_->::aggregator::FileID::Clear();
    }
    fb_cs_pos_ = 0u;
    fb_cs_count_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CheckSumRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .aggregator.FileID id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_fb_cs_pos;
        break;
      }
      
      // required uint32 fb_cs_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fb_cs_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fb_cs_pos_)));
          set_has_fb_cs_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_fb_cs_count;
        break;
      }
      
      // required uint32 fb_cs_count = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fb_cs_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fb_cs_count_)));
          set_has_fb_cs_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CheckSumRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .aggregator.FileID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->id(), output);
  }
  
  // required uint32 fb_cs_pos = 2;
  if (has_fb_cs_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->fb_cs_pos(), output);
  }
  
  // required uint32 fb_cs_count = 3;
  if (has_fb_cs_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->fb_cs_count(), output);
  }
  
}

int CheckSumRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .aggregator.FileID id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }
    
    // required uint32 fb_cs_pos = 2;
    if (has_fb_cs_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fb_cs_pos());
    }
    
    // required uint32 fb_cs_count = 3;
    if (has_fb_cs_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fb_cs_count());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckSumRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CheckSumRequest*>(&from));
}

void CheckSumRequest::MergeFrom(const CheckSumRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::aggregator::FileID::MergeFrom(from.id());
    }
    if (from.has_fb_cs_pos()) {
      set_fb_cs_pos(from.fb_cs_pos());
    }
    if (from.has_fb_cs_count()) {
      set_fb_cs_count(from.fb_cs_count());
    }
  }
}

void CheckSumRequest::CopyFrom(const CheckSumRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckSumRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_id()) {
    if (!this->id().IsInitialized()) return false;
  }
  return true;
}

void CheckSumRequest::Swap(CheckSumRequest* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(fb_cs_pos_, other->fb_cs_pos_);
    std::swap(fb_cs_count_, other->fb_cs_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CheckSumRequest::GetTypeName() const {
  return "aggregator.CheckSumRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int CheckSumResponse::kIdFieldNumber;
const int CheckSumResponse::kFbCsPosFieldNumber;
const int CheckSumResponse::kFbCsCountFieldNumber;
const int CheckSumResponse::kFbCsDataFieldNumber;
#endif  // !_MSC_VER

CheckSumResponse::CheckSumResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CheckSumResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_ = const_cast< ::aggregator::FileID*>(
      ::aggregator::FileID::internal_default_instance());
#else
  id_ = const_cast< ::aggregator::FileID*>(&::aggregator::FileID::default_instance());
#endif
}

CheckSumResponse::CheckSumResponse(const CheckSumResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CheckSumResponse::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  fb_cs_pos_ = 0u;
  fb_cs_count_ = 0u;
  fb_cs_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckSumResponse::~CheckSumResponse() {
  SharedDtor();
}

void CheckSumResponse::SharedDtor() {
  if (fb_cs_data_ != &::google::protobuf::internal::kEmptyString) {
    delete fb_cs_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_;
  }
}

void CheckSumResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CheckSumResponse& CheckSumResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

CheckSumResponse* CheckSumResponse::default_instance_ = NULL;

CheckSumResponse* CheckSumResponse::New() const {
  return new CheckSumResponse;
}

void CheckSumResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != NULL) id_->::aggregator::FileID::Clear();
    }
    fb_cs_pos_ = 0u;
    fb_cs_count_ = 0u;
    if (has_fb_cs_data()) {
      if (fb_cs_data_ != &::google::protobuf::internal::kEmptyString) {
        fb_cs_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CheckSumResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .aggregator.FileID id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_fb_cs_pos;
        break;
      }
      
      // required uint32 fb_cs_pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fb_cs_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fb_cs_pos_)));
          set_has_fb_cs_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_fb_cs_count;
        break;
      }
      
      // required uint32 fb_cs_count = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fb_cs_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fb_cs_count_)));
          set_has_fb_cs_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_fb_cs_data;
        break;
      }
      
      // optional bytes fb_cs_data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fb_cs_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_fb_cs_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CheckSumResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .aggregator.FileID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->id(), output);
  }
  
  // required uint32 fb_cs_pos = 2;
  if (has_fb_cs_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->fb_cs_pos(), output);
  }
  
  // required uint32 fb_cs_count = 3;
  if (has_fb_cs_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->fb_cs_count(), output);
  }
  
  // optional bytes fb_cs_data = 4;
  if (has_fb_cs_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->fb_cs_data(), output);
  }
  
}

int CheckSumResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .aggregator.FileID id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }
    
    // required uint32 fb_cs_pos = 2;
    if (has_fb_cs_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fb_cs_pos());
    }
    
    // required uint32 fb_cs_count = 3;
    if (has_fb_cs_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fb_cs_count());
    }
    
    // optional bytes fb_cs_data = 4;
    if (has_fb_cs_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->fb_cs_data());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckSumResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CheckSumResponse*>(&from));
}

void CheckSumResponse::MergeFrom(const CheckSumResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::aggregator::FileID::MergeFrom(from.id());
    }
    if (from.has_fb_cs_pos()) {
      set_fb_cs_pos(from.fb_cs_pos());
    }
    if (from.has_fb_cs_count()) {
      set_fb_cs_count(from.fb_cs_count());
    }
    if (from.has_fb_cs_data()) {
      set_fb_cs_data(from.fb_cs_data());
    }
  }
}

void CheckSumResponse::CopyFrom(const CheckSumResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckSumResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_id()) {
    if (!this->id().IsInitialized()) return false;
  }
  return true;
}

void CheckSumResponse::Swap(CheckSumResponse* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(fb_cs_pos_, other->fb_cs_pos_);
    std::swap(fb_cs_count_, other->fb_cs_count_);
    std::swap(fb_cs_data_, other->fb_cs_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CheckSumResponse::GetTypeName() const {
  return "aggregator.CheckSumResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int LogRequest::kTypeFieldNumber;
const int LogRequest::kDataFieldNumber;
const int LogRequest::kContentFieldNumber;
#endif  // !_MSC_VER

LogRequest::LogRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LogRequest::InitAsDefaultInstance() {
}

LogRequest::LogRequest(const LogRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LogRequest::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogRequest::~LogRequest() {
  SharedDtor();
}

void LogRequest::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LogRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LogRequest& LogRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

LogRequest* LogRequest::default_instance_ = NULL;

LogRequest* LogRequest::New() const {
  return new LogRequest;
}

void LogRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0u;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::kEmptyString) {
        content_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LogRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }
      
      // required string data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_content;
        break;
      }
      
      // optional bytes content = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }
  
  // required string data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->data(), output);
  }
  
  // optional bytes content = 3;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->content(), output);
  }
  
}

int LogRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }
    
    // required string data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->data());
    }
    
    // optional bytes content = 3;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->content());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LogRequest*>(&from));
}

void LogRequest::MergeFrom(const LogRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
  }
}

void LogRequest::CopyFrom(const LogRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void LogRequest::Swap(LogRequest* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(data_, other->data_);
    std::swap(content_, other->content_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LogRequest::GetTypeName() const {
  return "aggregator.LogRequest";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

LogResponse::LogResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LogResponse::InitAsDefaultInstance() {
}

LogResponse::LogResponse(const LogResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LogResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogResponse::~LogResponse() {
  SharedDtor();
}

void LogResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LogResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LogResponse& LogResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

LogResponse* LogResponse::default_instance_ = NULL;

LogResponse* LogResponse::New() const {
  return new LogResponse;
}

void LogResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LogResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
  }
  return true;
#undef DO_
}

void LogResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int LogResponse::ByteSize() const {
  int total_size = 0;
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LogResponse*>(&from));
}

void LogResponse::MergeFrom(const LogResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void LogResponse::CopyFrom(const LogResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogResponse::IsInitialized() const {
  
  return true;
}

void LogResponse::Swap(LogResponse* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LogResponse::GetTypeName() const {
  return "aggregator.LogResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int FileRequest_File::kDirFieldNumber;
const int FileRequest_File::kNameFieldNumber;
const int FileRequest_File::kCtimeFieldNumber;
#endif  // !_MSC_VER

FileRequest_File::FileRequest_File()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FileRequest_File::InitAsDefaultInstance() {
}

FileRequest_File::FileRequest_File(const FileRequest_File& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FileRequest_File::SharedCtor() {
  _cached_size_ = 0;
  dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ctime_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileRequest_File::~FileRequest_File() {
  SharedDtor();
}

void FileRequest_File::SharedDtor() {
  if (dir_ != &::google::protobuf::internal::kEmptyString) {
    delete dir_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FileRequest_File::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileRequest_File& FileRequest_File::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

FileRequest_File* FileRequest_File::default_instance_ = NULL;

FileRequest_File* FileRequest_File::New() const {
  return new FileRequest_File;
}

void FileRequest_File::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_dir()) {
      if (dir_ != &::google::protobuf::internal::kEmptyString) {
        dir_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    ctime_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FileRequest_File::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string dir = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dir()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ctime;
        break;
      }
      
      // required uint64 ctime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ctime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ctime_)));
          set_has_ctime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileRequest_File::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string dir = 1;
  if (has_dir()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->dir(), output);
  }
  
  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
  // required uint64 ctime = 3;
  if (has_ctime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->ctime(), output);
  }
  
}

int FileRequest_File::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string dir = 1;
    if (has_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dir());
    }
    
    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required uint64 ctime = 3;
    if (has_ctime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ctime());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileRequest_File::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileRequest_File*>(&from));
}

void FileRequest_File::MergeFrom(const FileRequest_File& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dir()) {
      set_dir(from.dir());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_ctime()) {
      set_ctime(from.ctime());
    }
  }
}

void FileRequest_File::CopyFrom(const FileRequest_File& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileRequest_File::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void FileRequest_File::Swap(FileRequest_File* other) {
  if (other != this) {
    std::swap(dir_, other->dir_);
    std::swap(name_, other->name_);
    std::swap(ctime_, other->ctime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FileRequest_File::GetTypeName() const {
  return "aggregator.FileRequest.File";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int FileRequest::kFileFieldNumber;
#endif  // !_MSC_VER

FileRequest::FileRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FileRequest::InitAsDefaultInstance() {
}

FileRequest::FileRequest(const FileRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FileRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileRequest::~FileRequest() {
  SharedDtor();
}

void FileRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FileRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileRequest& FileRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

FileRequest* FileRequest::default_instance_ = NULL;

FileRequest* FileRequest::New() const {
  return new FileRequest;
}

void FileRequest::Clear() {
  file_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FileRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group File = 1 {
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_START_GROUP) {
         parse_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_file()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(11)) goto parse_file;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated group File = 1 {
  for (int i = 0; i < this->file_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->file(i), output);
  }
  
}

int FileRequest::ByteSize() const {
  int total_size = 0;
  
  // repeated group File = 1 {
  total_size += 2 * this->file_size();
  for (int i = 0; i < this->file_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->file(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileRequest*>(&from));
}

void FileRequest::MergeFrom(const FileRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  file_.MergeFrom(from.file_);
}

void FileRequest::CopyFrom(const FileRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileRequest::IsInitialized() const {
  
  for (int i = 0; i < file_size(); i++) {
    if (!this->file(i).IsInitialized()) return false;
  }
  return true;
}

void FileRequest::Swap(FileRequest* other) {
  if (other != this) {
    file_.Swap(&other->file_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FileRequest::GetTypeName() const {
  return "aggregator.FileRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int FileResponse_File::kIdFieldNumber;
const int FileResponse_File::kDirFieldNumber;
const int FileResponse_File::kNameFieldNumber;
#endif  // !_MSC_VER

FileResponse_File::FileResponse_File()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FileResponse_File::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_ = const_cast< ::aggregator::FileID*>(
      ::aggregator::FileID::internal_default_instance());
#else
  id_ = const_cast< ::aggregator::FileID*>(&::aggregator::FileID::default_instance());
#endif
}

FileResponse_File::FileResponse_File(const FileResponse_File& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FileResponse_File::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileResponse_File::~FileResponse_File() {
  SharedDtor();
}

void FileResponse_File::SharedDtor() {
  if (dir_ != &::google::protobuf::internal::kEmptyString) {
    delete dir_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_;
  }
}

void FileResponse_File::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileResponse_File& FileResponse_File::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

FileResponse_File* FileResponse_File::default_instance_ = NULL;

FileResponse_File* FileResponse_File::New() const {
  return new FileResponse_File;
}

void FileResponse_File::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != NULL) id_->::aggregator::FileID::Clear();
    }
    if (has_dir()) {
      if (dir_ != &::google::protobuf::internal::kEmptyString) {
        dir_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FileResponse_File::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .aggregator.FileID id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_dir;
        break;
      }
      
      // required string dir = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dir()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }
      
      // required string name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileResponse_File::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .aggregator.FileID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->id(), output);
  }
  
  // required string dir = 2;
  if (has_dir()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->dir(), output);
  }
  
  // required string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->name(), output);
  }
  
}

int FileResponse_File::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .aggregator.FileID id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }
    
    // required string dir = 2;
    if (has_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dir());
    }
    
    // required string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileResponse_File::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileResponse_File*>(&from));
}

void FileResponse_File::MergeFrom(const FileResponse_File& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::aggregator::FileID::MergeFrom(from.id());
    }
    if (from.has_dir()) {
      set_dir(from.dir());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void FileResponse_File::CopyFrom(const FileResponse_File& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileResponse_File::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_id()) {
    if (!this->id().IsInitialized()) return false;
  }
  return true;
}

void FileResponse_File::Swap(FileResponse_File* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(dir_, other->dir_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FileResponse_File::GetTypeName() const {
  return "aggregator.FileResponse.File";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int FileResponse::kFileFieldNumber;
#endif  // !_MSC_VER

FileResponse::FileResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FileResponse::InitAsDefaultInstance() {
}

FileResponse::FileResponse(const FileResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FileResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileResponse::~FileResponse() {
  SharedDtor();
}

void FileResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FileResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileResponse& FileResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

FileResponse* FileResponse::default_instance_ = NULL;

FileResponse* FileResponse::New() const {
  return new FileResponse;
}

void FileResponse::Clear() {
  file_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FileResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group File = 1 {
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_START_GROUP) {
         parse_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_file()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(11)) goto parse_file;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated group File = 1 {
  for (int i = 0; i < this->file_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->file(i), output);
  }
  
}

int FileResponse::ByteSize() const {
  int total_size = 0;
  
  // repeated group File = 1 {
  total_size += 2 * this->file_size();
  for (int i = 0; i < this->file_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->file(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileResponse*>(&from));
}

void FileResponse::MergeFrom(const FileResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  file_.MergeFrom(from.file_);
}

void FileResponse::CopyFrom(const FileResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileResponse::IsInitialized() const {
  
  for (int i = 0; i < file_size(); i++) {
    if (!this->file(i).IsInitialized()) return false;
  }
  return true;
}

void FileResponse::Swap(FileResponse* other) {
  if (other != this) {
    file_.Swap(&other->file_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FileResponse::GetTypeName() const {
  return "aggregator.FileResponse";
}


// ===================================================================

bool FileDataRequest_FileData_EncodeType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FileDataRequest_FileData_EncodeType FileDataRequest_FileData::NONE;
const FileDataRequest_FileData_EncodeType FileDataRequest_FileData::DEFLATE;
const FileDataRequest_FileData_EncodeType FileDataRequest_FileData::EncodeType_MIN;
const FileDataRequest_FileData_EncodeType FileDataRequest_FileData::EncodeType_MAX;
const int FileDataRequest_FileData::EncodeType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FileDataRequest_FileData::kIdFieldNumber;
const int FileDataRequest_FileData::kPosFieldNumber;
const int FileDataRequest_FileData::kEncodeFieldNumber;
const int FileDataRequest_FileData::kOrgLenFieldNumber;
const int FileDataRequest_FileData::kDataFieldNumber;
#endif  // !_MSC_VER

FileDataRequest_FileData::FileDataRequest_FileData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FileDataRequest_FileData::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_ = const_cast< ::aggregator::FileID*>(
      ::aggregator::FileID::internal_default_instance());
#else
  id_ = const_cast< ::aggregator::FileID*>(&::aggregator::FileID::default_instance());
#endif
}

FileDataRequest_FileData::FileDataRequest_FileData(const FileDataRequest_FileData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FileDataRequest_FileData::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  pos_ = GOOGLE_ULONGLONG(0);
  encode_ = 0;
  org_len_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileDataRequest_FileData::~FileDataRequest_FileData() {
  SharedDtor();
}

void FileDataRequest_FileData::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_;
  }
}

void FileDataRequest_FileData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileDataRequest_FileData& FileDataRequest_FileData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

FileDataRequest_FileData* FileDataRequest_FileData::default_instance_ = NULL;

FileDataRequest_FileData* FileDataRequest_FileData::New() const {
  return new FileDataRequest_FileData;
}

void FileDataRequest_FileData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != NULL) id_->::aggregator::FileID::Clear();
    }
    pos_ = GOOGLE_ULONGLONG(0);
    encode_ = 0;
    org_len_ = 0u;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FileDataRequest_FileData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .aggregator.FileID id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_pos;
        break;
      }
      
      // required uint64 pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_encode;
        break;
      }
      
      // required .aggregator.FileDataRequest.FileData.EncodeType encode = 3 [default = NONE];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_encode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::aggregator::FileDataRequest_FileData_EncodeType_IsValid(value)) {
            set_encode(static_cast< ::aggregator::FileDataRequest_FileData_EncodeType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_org_len;
        break;
      }
      
      // optional uint32 org_len = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_org_len:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &org_len_)));
          set_has_org_len();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_data;
        break;
      }
      
      // required bytes data = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileDataRequest_FileData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .aggregator.FileID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->id(), output);
  }
  
  // required uint64 pos = 2;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->pos(), output);
  }
  
  // required .aggregator.FileDataRequest.FileData.EncodeType encode = 3 [default = NONE];
  if (has_encode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->encode(), output);
  }
  
  // optional uint32 org_len = 4;
  if (has_org_len()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->org_len(), output);
  }
  
  // required bytes data = 6;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->data(), output);
  }
  
}

int FileDataRequest_FileData::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .aggregator.FileID id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }
    
    // required uint64 pos = 2;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pos());
    }
    
    // required .aggregator.FileDataRequest.FileData.EncodeType encode = 3 [default = NONE];
    if (has_encode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->encode());
    }
    
    // optional uint32 org_len = 4;
    if (has_org_len()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->org_len());
    }
    
    // required bytes data = 6;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileDataRequest_FileData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileDataRequest_FileData*>(&from));
}

void FileDataRequest_FileData::MergeFrom(const FileDataRequest_FileData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::aggregator::FileID::MergeFrom(from.id());
    }
    if (from.has_pos()) {
      set_pos(from.pos());
    }
    if (from.has_encode()) {
      set_encode(from.encode());
    }
    if (from.has_org_len()) {
      set_org_len(from.org_len());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
}

void FileDataRequest_FileData::CopyFrom(const FileDataRequest_FileData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileDataRequest_FileData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000017) != 0x00000017) return false;
  
  if (has_id()) {
    if (!this->id().IsInitialized()) return false;
  }
  return true;
}

void FileDataRequest_FileData::Swap(FileDataRequest_FileData* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(pos_, other->pos_);
    std::swap(encode_, other->encode_);
    std::swap(org_len_, other->org_len_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FileDataRequest_FileData::GetTypeName() const {
  return "aggregator.FileDataRequest.FileData";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int FileDataRequest::kFiledataFieldNumber;
#endif  // !_MSC_VER

FileDataRequest::FileDataRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FileDataRequest::InitAsDefaultInstance() {
}

FileDataRequest::FileDataRequest(const FileDataRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FileDataRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileDataRequest::~FileDataRequest() {
  SharedDtor();
}

void FileDataRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FileDataRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileDataRequest& FileDataRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

FileDataRequest* FileDataRequest::default_instance_ = NULL;

FileDataRequest* FileDataRequest::New() const {
  return new FileDataRequest;
}

void FileDataRequest::Clear() {
  filedata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FileDataRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group FileData = 1 {
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_START_GROUP) {
         parse_filedata:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_filedata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(11)) goto parse_filedata;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileDataRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated group FileData = 1 {
  for (int i = 0; i < this->filedata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->filedata(i), output);
  }
  
}

int FileDataRequest::ByteSize() const {
  int total_size = 0;
  
  // repeated group FileData = 1 {
  total_size += 2 * this->filedata_size();
  for (int i = 0; i < this->filedata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->filedata(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileDataRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileDataRequest*>(&from));
}

void FileDataRequest::MergeFrom(const FileDataRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  filedata_.MergeFrom(from.filedata_);
}

void FileDataRequest::CopyFrom(const FileDataRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileDataRequest::IsInitialized() const {
  
  for (int i = 0; i < filedata_size(); i++) {
    if (!this->filedata(i).IsInitialized()) return false;
  }
  return true;
}

void FileDataRequest::Swap(FileDataRequest* other) {
  if (other != this) {
    filedata_.Swap(&other->filedata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FileDataRequest::GetTypeName() const {
  return "aggregator.FileDataRequest";
}


// ===================================================================

bool FileDataResponse_FileData_FileStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FileDataResponse_FileData_FileStatus FileDataResponse_FileData::PROCESS;
const FileDataResponse_FileData_FileStatus FileDataResponse_FileData::FINISH;
const FileDataResponse_FileData_FileStatus FileDataResponse_FileData::FileStatus_MIN;
const FileDataResponse_FileData_FileStatus FileDataResponse_FileData::FileStatus_MAX;
const int FileDataResponse_FileData::FileStatus_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FileDataResponse_FileData::kIdFieldNumber;
const int FileDataResponse_FileData::kSizeFieldNumber;
const int FileDataResponse_FileData::kStatusFieldNumber;
const int FileDataResponse_FileData::kChecksumFieldNumber;
#endif  // !_MSC_VER

FileDataResponse_FileData::FileDataResponse_FileData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FileDataResponse_FileData::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_ = const_cast< ::aggregator::FileID*>(
      ::aggregator::FileID::internal_default_instance());
#else
  id_ = const_cast< ::aggregator::FileID*>(&::aggregator::FileID::default_instance());
#endif
}

FileDataResponse_FileData::FileDataResponse_FileData(const FileDataResponse_FileData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FileDataResponse_FileData::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  size_ = GOOGLE_ULONGLONG(0);
  status_ = 0;
  checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileDataResponse_FileData::~FileDataResponse_FileData() {
  SharedDtor();
}

void FileDataResponse_FileData::SharedDtor() {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    delete checksum_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_;
  }
}

void FileDataResponse_FileData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileDataResponse_FileData& FileDataResponse_FileData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

FileDataResponse_FileData* FileDataResponse_FileData::default_instance_ = NULL;

FileDataResponse_FileData* FileDataResponse_FileData::New() const {
  return new FileDataResponse_FileData;
}

void FileDataResponse_FileData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != NULL) id_->::aggregator::FileID::Clear();
    }
    size_ = GOOGLE_ULONGLONG(0);
    status_ = 0;
    if (has_checksum()) {
      if (checksum_ != &::google::protobuf::internal::kEmptyString) {
        checksum_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FileDataResponse_FileData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .aggregator.FileID id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_size;
        break;
      }
      
      // required uint64 size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }
      
      // optional .aggregator.FileDataResponse.FileData.FileStatus status = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::aggregator::FileDataResponse_FileData_FileStatus_IsValid(value)) {
            set_status(static_cast< ::aggregator::FileDataResponse_FileData_FileStatus >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_checksum;
        break;
      }
      
      // optional string checksum = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_checksum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_checksum()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileDataResponse_FileData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .aggregator.FileID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->id(), output);
  }
  
  // required uint64 size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->size(), output);
  }
  
  // optional .aggregator.FileDataResponse.FileData.FileStatus status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->status(), output);
  }
  
  // optional string checksum = 4;
  if (has_checksum()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->checksum(), output);
  }
  
}

int FileDataResponse_FileData::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .aggregator.FileID id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }
    
    // required uint64 size = 2;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }
    
    // optional .aggregator.FileDataResponse.FileData.FileStatus status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }
    
    // optional string checksum = 4;
    if (has_checksum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->checksum());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileDataResponse_FileData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileDataResponse_FileData*>(&from));
}

void FileDataResponse_FileData::MergeFrom(const FileDataResponse_FileData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::aggregator::FileID::MergeFrom(from.id());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_checksum()) {
      set_checksum(from.checksum());
    }
  }
}

void FileDataResponse_FileData::CopyFrom(const FileDataResponse_FileData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileDataResponse_FileData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_id()) {
    if (!this->id().IsInitialized()) return false;
  }
  return true;
}

void FileDataResponse_FileData::Swap(FileDataResponse_FileData* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(size_, other->size_);
    std::swap(status_, other->status_);
    std::swap(checksum_, other->checksum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FileDataResponse_FileData::GetTypeName() const {
  return "aggregator.FileDataResponse.FileData";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int FileDataResponse::kFiledataFieldNumber;
#endif  // !_MSC_VER

FileDataResponse::FileDataResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FileDataResponse::InitAsDefaultInstance() {
}

FileDataResponse::FileDataResponse(const FileDataResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FileDataResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileDataResponse::~FileDataResponse() {
  SharedDtor();
}

void FileDataResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FileDataResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileDataResponse& FileDataResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

FileDataResponse* FileDataResponse::default_instance_ = NULL;

FileDataResponse* FileDataResponse::New() const {
  return new FileDataResponse;
}

void FileDataResponse::Clear() {
  filedata_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FileDataResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group FileData = 1 {
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_START_GROUP) {
         parse_filedata:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_filedata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(11)) goto parse_filedata;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileDataResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated group FileData = 1 {
  for (int i = 0; i < this->filedata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->filedata(i), output);
  }
  
}

int FileDataResponse::ByteSize() const {
  int total_size = 0;
  
  // repeated group FileData = 1 {
  total_size += 2 * this->filedata_size();
  for (int i = 0; i < this->filedata_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->filedata(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileDataResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileDataResponse*>(&from));
}

void FileDataResponse::MergeFrom(const FileDataResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  filedata_.MergeFrom(from.filedata_);
}

void FileDataResponse::CopyFrom(const FileDataResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileDataResponse::IsInitialized() const {
  
  for (int i = 0; i < filedata_size(); i++) {
    if (!this->filedata(i).IsInitialized()) return false;
  }
  return true;
}

void FileDataResponse::Swap(FileDataResponse* other) {
  if (other != this) {
    filedata_.Swap(&other->filedata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FileDataResponse::GetTypeName() const {
  return "aggregator.FileDataResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CollectorFileRequest::CollectorFileRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CollectorFileRequest::InitAsDefaultInstance() {
}

CollectorFileRequest::CollectorFileRequest(const CollectorFileRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CollectorFileRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectorFileRequest::~CollectorFileRequest() {
  SharedDtor();
}

void CollectorFileRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CollectorFileRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CollectorFileRequest& CollectorFileRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

CollectorFileRequest* CollectorFileRequest::default_instance_ = NULL;

CollectorFileRequest* CollectorFileRequest::New() const {
  return new CollectorFileRequest;
}

void CollectorFileRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CollectorFileRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
  }
  return true;
#undef DO_
}

void CollectorFileRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int CollectorFileRequest::ByteSize() const {
  int total_size = 0;
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectorFileRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CollectorFileRequest*>(&from));
}

void CollectorFileRequest::MergeFrom(const CollectorFileRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void CollectorFileRequest::CopyFrom(const CollectorFileRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectorFileRequest::IsInitialized() const {
  
  return true;
}

void CollectorFileRequest::Swap(CollectorFileRequest* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CollectorFileRequest::GetTypeName() const {
  return "aggregator.CollectorFileRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int CollectorFileResponse_File::kIdFieldNumber;
const int CollectorFileResponse_File::kPosFieldNumber;
const int CollectorFileResponse_File::kFinishFieldNumber;
const int CollectorFileResponse_File::kDirFieldNumber;
const int CollectorFileResponse_File::kNameFieldNumber;
#endif  // !_MSC_VER

CollectorFileResponse_File::CollectorFileResponse_File()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CollectorFileResponse_File::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_ = const_cast< ::aggregator::FileID*>(
      ::aggregator::FileID::internal_default_instance());
#else
  id_ = const_cast< ::aggregator::FileID*>(&::aggregator::FileID::default_instance());
#endif
}

CollectorFileResponse_File::CollectorFileResponse_File(const CollectorFileResponse_File& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CollectorFileResponse_File::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  pos_ = GOOGLE_ULONGLONG(0);
  finish_ = false;
  dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectorFileResponse_File::~CollectorFileResponse_File() {
  SharedDtor();
}

void CollectorFileResponse_File::SharedDtor() {
  if (dir_ != &::google::protobuf::internal::kEmptyString) {
    delete dir_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_;
  }
}

void CollectorFileResponse_File::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CollectorFileResponse_File& CollectorFileResponse_File::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

CollectorFileResponse_File* CollectorFileResponse_File::default_instance_ = NULL;

CollectorFileResponse_File* CollectorFileResponse_File::New() const {
  return new CollectorFileResponse_File;
}

void CollectorFileResponse_File::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != NULL) id_->::aggregator::FileID::Clear();
    }
    pos_ = GOOGLE_ULONGLONG(0);
    finish_ = false;
    if (has_dir()) {
      if (dir_ != &::google::protobuf::internal::kEmptyString) {
        dir_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CollectorFileResponse_File::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .aggregator.FileID id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_pos;
        break;
      }
      
      // required uint64 pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_finish;
        break;
      }
      
      // required bool finish = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_finish:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &finish_)));
          set_has_finish();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_dir;
        break;
      }
      
      // required string dir = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dir()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_name;
        break;
      }
      
      // required string name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollectorFileResponse_File::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .aggregator.FileID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->id(), output);
  }
  
  // required uint64 pos = 2;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->pos(), output);
  }
  
  // required bool finish = 3;
  if (has_finish()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->finish(), output);
  }
  
  // required string dir = 4;
  if (has_dir()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->dir(), output);
  }
  
  // required string name = 5;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->name(), output);
  }
  
}

int CollectorFileResponse_File::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .aggregator.FileID id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }
    
    // required uint64 pos = 2;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pos());
    }
    
    // required bool finish = 3;
    if (has_finish()) {
      total_size += 1 + 1;
    }
    
    // required string dir = 4;
    if (has_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dir());
    }
    
    // required string name = 5;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectorFileResponse_File::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CollectorFileResponse_File*>(&from));
}

void CollectorFileResponse_File::MergeFrom(const CollectorFileResponse_File& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::aggregator::FileID::MergeFrom(from.id());
    }
    if (from.has_pos()) {
      set_pos(from.pos());
    }
    if (from.has_finish()) {
      set_finish(from.finish());
    }
    if (from.has_dir()) {
      set_dir(from.dir());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void CollectorFileResponse_File::CopyFrom(const CollectorFileResponse_File& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectorFileResponse_File::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  if (has_id()) {
    if (!this->id().IsInitialized()) return false;
  }
  return true;
}

void CollectorFileResponse_File::Swap(CollectorFileResponse_File* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(pos_, other->pos_);
    std::swap(finish_, other->finish_);
    std::swap(dir_, other->dir_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CollectorFileResponse_File::GetTypeName() const {
  return "aggregator.CollectorFileResponse.File";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CollectorFileResponse::kFileFieldNumber;
#endif  // !_MSC_VER

CollectorFileResponse::CollectorFileResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CollectorFileResponse::InitAsDefaultInstance() {
}

CollectorFileResponse::CollectorFileResponse(const CollectorFileResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CollectorFileResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectorFileResponse::~CollectorFileResponse() {
  SharedDtor();
}

void CollectorFileResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CollectorFileResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CollectorFileResponse& CollectorFileResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

CollectorFileResponse* CollectorFileResponse::default_instance_ = NULL;

CollectorFileResponse* CollectorFileResponse::New() const {
  return new CollectorFileResponse;
}

void CollectorFileResponse::Clear() {
  file_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CollectorFileResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group File = 1 {
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_START_GROUP) {
         parse_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_file()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(11)) goto parse_file;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollectorFileResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated group File = 1 {
  for (int i = 0; i < this->file_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->file(i), output);
  }
  
}

int CollectorFileResponse::ByteSize() const {
  int total_size = 0;
  
  // repeated group File = 1 {
  total_size += 2 * this->file_size();
  for (int i = 0; i < this->file_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->file(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectorFileResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CollectorFileResponse*>(&from));
}

void CollectorFileResponse::MergeFrom(const CollectorFileResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  file_.MergeFrom(from.file_);
}

void CollectorFileResponse::CopyFrom(const CollectorFileResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectorFileResponse::IsInitialized() const {
  
  for (int i = 0; i < file_size(); i++) {
    if (!this->file(i).IsInitialized()) return false;
  }
  return true;
}

void CollectorFileResponse::Swap(CollectorFileResponse* other) {
  if (other != this) {
    file_.Swap(&other->file_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CollectorFileResponse::GetTypeName() const {
  return "aggregator.CollectorFileResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CollectRuleRequest::CollectRuleRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CollectRuleRequest::InitAsDefaultInstance() {
}

CollectRuleRequest::CollectRuleRequest(const CollectRuleRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CollectRuleRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectRuleRequest::~CollectRuleRequest() {
  SharedDtor();
}

void CollectRuleRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CollectRuleRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CollectRuleRequest& CollectRuleRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

CollectRuleRequest* CollectRuleRequest::default_instance_ = NULL;

CollectRuleRequest* CollectRuleRequest::New() const {
  return new CollectRuleRequest;
}

void CollectRuleRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CollectRuleRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
  }
  return true;
#undef DO_
}

void CollectRuleRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int CollectRuleRequest::ByteSize() const {
  int total_size = 0;
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectRuleRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CollectRuleRequest*>(&from));
}

void CollectRuleRequest::MergeFrom(const CollectRuleRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void CollectRuleRequest::CopyFrom(const CollectRuleRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectRuleRequest::IsInitialized() const {
  
  return true;
}

void CollectRuleRequest::Swap(CollectRuleRequest* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CollectRuleRequest::GetTypeName() const {
  return "aggregator.CollectRuleRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int CollectRuleResponse_Rule::kDirFieldNumber;
const int CollectRuleResponse_Rule::kExcludeFieldNumber;
const int CollectRuleResponse_Rule::kIncludeFieldNumber;
#endif  // !_MSC_VER

CollectRuleResponse_Rule::CollectRuleResponse_Rule()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CollectRuleResponse_Rule::InitAsDefaultInstance() {
}

CollectRuleResponse_Rule::CollectRuleResponse_Rule(const CollectRuleResponse_Rule& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CollectRuleResponse_Rule::SharedCtor() {
  _cached_size_ = 0;
  dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  exclude_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  include_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectRuleResponse_Rule::~CollectRuleResponse_Rule() {
  SharedDtor();
}

void CollectRuleResponse_Rule::SharedDtor() {
  if (dir_ != &::google::protobuf::internal::kEmptyString) {
    delete dir_;
  }
  if (exclude_ != &::google::protobuf::internal::kEmptyString) {
    delete exclude_;
  }
  if (include_ != &::google::protobuf::internal::kEmptyString) {
    delete include_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CollectRuleResponse_Rule::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CollectRuleResponse_Rule& CollectRuleResponse_Rule::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

CollectRuleResponse_Rule* CollectRuleResponse_Rule::default_instance_ = NULL;

CollectRuleResponse_Rule* CollectRuleResponse_Rule::New() const {
  return new CollectRuleResponse_Rule;
}

void CollectRuleResponse_Rule::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_dir()) {
      if (dir_ != &::google::protobuf::internal::kEmptyString) {
        dir_->clear();
      }
    }
    if (has_exclude()) {
      if (exclude_ != &::google::protobuf::internal::kEmptyString) {
        exclude_->clear();
      }
    }
    if (has_include()) {
      if (include_ != &::google::protobuf::internal::kEmptyString) {
        include_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CollectRuleResponse_Rule::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string dir = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dir()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_exclude;
        break;
      }
      
      // optional string exclude = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exclude:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_exclude()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_include;
        break;
      }
      
      // required string include = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_include:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_include()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollectRuleResponse_Rule::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string dir = 1;
  if (has_dir()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->dir(), output);
  }
  
  // optional string exclude = 2;
  if (has_exclude()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->exclude(), output);
  }
  
  // required string include = 3;
  if (has_include()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->include(), output);
  }
  
}

int CollectRuleResponse_Rule::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string dir = 1;
    if (has_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dir());
    }
    
    // optional string exclude = 2;
    if (has_exclude()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->exclude());
    }
    
    // required string include = 3;
    if (has_include()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->include());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectRuleResponse_Rule::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CollectRuleResponse_Rule*>(&from));
}

void CollectRuleResponse_Rule::MergeFrom(const CollectRuleResponse_Rule& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dir()) {
      set_dir(from.dir());
    }
    if (from.has_exclude()) {
      set_exclude(from.exclude());
    }
    if (from.has_include()) {
      set_include(from.include());
    }
  }
}

void CollectRuleResponse_Rule::CopyFrom(const CollectRuleResponse_Rule& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectRuleResponse_Rule::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  
  return true;
}

void CollectRuleResponse_Rule::Swap(CollectRuleResponse_Rule* other) {
  if (other != this) {
    std::swap(dir_, other->dir_);
    std::swap(exclude_, other->exclude_);
    std::swap(include_, other->include_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CollectRuleResponse_Rule::GetTypeName() const {
  return "aggregator.CollectRuleResponse.Rule";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CollectRuleResponse::kRuleFieldNumber;
#endif  // !_MSC_VER

CollectRuleResponse::CollectRuleResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CollectRuleResponse::InitAsDefaultInstance() {
}

CollectRuleResponse::CollectRuleResponse(const CollectRuleResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CollectRuleResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectRuleResponse::~CollectRuleResponse() {
  SharedDtor();
}

void CollectRuleResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CollectRuleResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CollectRuleResponse& CollectRuleResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

CollectRuleResponse* CollectRuleResponse::default_instance_ = NULL;

CollectRuleResponse* CollectRuleResponse::New() const {
  return new CollectRuleResponse;
}

void CollectRuleResponse::Clear() {
  rule_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CollectRuleResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Rule = 1 {
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_START_GROUP) {
         parse_rule:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_rule()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(11)) goto parse_rule;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollectRuleResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated group Rule = 1 {
  for (int i = 0; i < this->rule_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->rule(i), output);
  }
  
}

int CollectRuleResponse::ByteSize() const {
  int total_size = 0;
  
  // repeated group Rule = 1 {
  total_size += 2 * this->rule_size();
  for (int i = 0; i < this->rule_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->rule(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectRuleResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CollectRuleResponse*>(&from));
}

void CollectRuleResponse::MergeFrom(const CollectRuleResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  rule_.MergeFrom(from.rule_);
}

void CollectRuleResponse::CopyFrom(const CollectRuleResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectRuleResponse::IsInitialized() const {
  
  for (int i = 0; i < rule_size(); i++) {
    if (!this->rule(i).IsInitialized()) return false;
  }
  return true;
}

void CollectRuleResponse::Swap(CollectRuleResponse* other) {
  if (other != this) {
    rule_.Swap(&other->rule_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CollectRuleResponse::GetTypeName() const {
  return "aggregator.CollectRuleResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ConfigRequest::ConfigRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ConfigRequest::InitAsDefaultInstance() {
}

ConfigRequest::ConfigRequest(const ConfigRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ConfigRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConfigRequest::~ConfigRequest() {
  SharedDtor();
}

void ConfigRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConfigRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConfigRequest& ConfigRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

ConfigRequest* ConfigRequest::default_instance_ = NULL;

ConfigRequest* ConfigRequest::New() const {
  return new ConfigRequest;
}

void ConfigRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ConfigRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
  }
  return true;
#undef DO_
}

void ConfigRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int ConfigRequest::ByteSize() const {
  int total_size = 0;
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConfigRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConfigRequest*>(&from));
}

void ConfigRequest::MergeFrom(const ConfigRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void ConfigRequest::CopyFrom(const ConfigRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigRequest::IsInitialized() const {
  
  return true;
}

void ConfigRequest::Swap(ConfigRequest* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConfigRequest::GetTypeName() const {
  return "aggregator.ConfigRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int ConfigResponse_Time::kNoFieldNumber;
const int ConfigResponse_Time::kKeepaliveFieldNumber;
const int ConfigResponse_Time::kRateFieldNumber;
const int ConfigResponse_Time::kStartFieldNumber;
const int ConfigResponse_Time::kEndFieldNumber;
const int ConfigResponse_Time::kSteptimeFieldNumber;
#endif  // !_MSC_VER

ConfigResponse_Time::ConfigResponse_Time()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ConfigResponse_Time::InitAsDefaultInstance() {
}

ConfigResponse_Time::ConfigResponse_Time(const ConfigResponse_Time& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ConfigResponse_Time::SharedCtor() {
  _cached_size_ = 0;
  no_ = 0u;
  keepalive_ = 0u;
  rate_ = 0u;
  start_ = 0u;
  end_ = 0u;
  steptime_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConfigResponse_Time::~ConfigResponse_Time() {
  SharedDtor();
}

void ConfigResponse_Time::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConfigResponse_Time::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConfigResponse_Time& ConfigResponse_Time::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

ConfigResponse_Time* ConfigResponse_Time::default_instance_ = NULL;

ConfigResponse_Time* ConfigResponse_Time::New() const {
  return new ConfigResponse_Time;
}

void ConfigResponse_Time::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    no_ = 0u;
    keepalive_ = 0u;
    rate_ = 0u;
    start_ = 0u;
    end_ = 0u;
    steptime_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ConfigResponse_Time::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 no = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &no_)));
          set_has_no();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_keepalive;
        break;
      }
      
      // required uint32 keepalive = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_keepalive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &keepalive_)));
          set_has_keepalive();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_rate;
        break;
      }
      
      // required uint32 rate = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rate_)));
          set_has_rate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_start;
        break;
      }
      
      // required uint32 start = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &start_)));
          set_has_start();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_end;
        break;
      }
      
      // required uint32 end = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_)));
          set_has_end();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_steptime;
        break;
      }
      
      // required uint32 steptime = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_steptime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &steptime_)));
          set_has_steptime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ConfigResponse_Time::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 no = 1;
  if (has_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->no(), output);
  }
  
  // required uint32 keepalive = 2;
  if (has_keepalive()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->keepalive(), output);
  }
  
  // required uint32 rate = 3;
  if (has_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->rate(), output);
  }
  
  // required uint32 start = 4;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->start(), output);
  }
  
  // required uint32 end = 5;
  if (has_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->end(), output);
  }
  
  // required uint32 steptime = 6;
  if (has_steptime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->steptime(), output);
  }
  
}

int ConfigResponse_Time::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 no = 1;
    if (has_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->no());
    }
    
    // required uint32 keepalive = 2;
    if (has_keepalive()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->keepalive());
    }
    
    // required uint32 rate = 3;
    if (has_rate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rate());
    }
    
    // required uint32 start = 4;
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->start());
    }
    
    // required uint32 end = 5;
    if (has_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end());
    }
    
    // required uint32 steptime = 6;
    if (has_steptime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->steptime());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConfigResponse_Time::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConfigResponse_Time*>(&from));
}

void ConfigResponse_Time::MergeFrom(const ConfigResponse_Time& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_no()) {
      set_no(from.no());
    }
    if (from.has_keepalive()) {
      set_keepalive(from.keepalive());
    }
    if (from.has_rate()) {
      set_rate(from.rate());
    }
    if (from.has_start()) {
      set_start(from.start());
    }
    if (from.has_end()) {
      set_end(from.end());
    }
    if (from.has_steptime()) {
      set_steptime(from.steptime());
    }
  }
}

void ConfigResponse_Time::CopyFrom(const ConfigResponse_Time& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigResponse_Time::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  
  return true;
}

void ConfigResponse_Time::Swap(ConfigResponse_Time* other) {
  if (other != this) {
    std::swap(no_, other->no_);
    std::swap(keepalive_, other->keepalive_);
    std::swap(rate_, other->rate_);
    std::swap(start_, other->start_);
    std::swap(end_, other->end_);
    std::swap(steptime_, other->steptime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConfigResponse_Time::GetTypeName() const {
  return "aggregator.ConfigResponse.Time";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ConfigResponse::kTimeFieldNumber;
#endif  // !_MSC_VER

ConfigResponse::ConfigResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ConfigResponse::InitAsDefaultInstance() {
}

ConfigResponse::ConfigResponse(const ConfigResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ConfigResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConfigResponse::~ConfigResponse() {
  SharedDtor();
}

void ConfigResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConfigResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConfigResponse& ConfigResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

ConfigResponse* ConfigResponse::default_instance_ = NULL;

ConfigResponse* ConfigResponse::New() const {
  return new ConfigResponse;
}

void ConfigResponse::Clear() {
  time_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ConfigResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Time = 1 {
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_START_GROUP) {
         parse_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(11)) goto parse_time;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ConfigResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated group Time = 1 {
  for (int i = 0; i < this->time_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->time(i), output);
  }
  
}

int ConfigResponse::ByteSize() const {
  int total_size = 0;
  
  // repeated group Time = 1 {
  total_size += 2 * this->time_size();
  for (int i = 0; i < this->time_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->time(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConfigResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConfigResponse*>(&from));
}

void ConfigResponse::MergeFrom(const ConfigResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  time_.MergeFrom(from.time_);
}

void ConfigResponse::CopyFrom(const ConfigResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigResponse::IsInitialized() const {
  
  for (int i = 0; i < time_size(); i++) {
    if (!this->time(i).IsInitialized()) return false;
  }
  return true;
}

void ConfigResponse::Swap(ConfigResponse* other) {
  if (other != this) {
    time_.Swap(&other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConfigResponse::GetTypeName() const {
  return "aggregator.ConfigResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int LogonRequest::kVerFieldNumber;
const int LogonRequest::kNameFieldNumber;
const int LogonRequest::kInfoFieldNumber;
#endif  // !_MSC_VER

LogonRequest::LogonRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LogonRequest::InitAsDefaultInstance() {
}

LogonRequest::LogonRequest(const LogonRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LogonRequest::SharedCtor() {
  _cached_size_ = 0;
  ver_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogonRequest::~LogonRequest() {
  SharedDtor();
}

void LogonRequest::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LogonRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LogonRequest& LogonRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

LogonRequest* LogonRequest::default_instance_ = NULL;

LogonRequest* LogonRequest::New() const {
  return new LogonRequest;
}

void LogonRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ver_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_info()) {
      if (info_ != &::google::protobuf::internal::kEmptyString) {
        info_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LogonRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ver = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ver_)));
          set_has_ver();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_info;
        break;
      }
      
      // optional bytes info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogonRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 ver = 1;
  if (has_ver()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ver(), output);
  }
  
  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
  // optional bytes info = 3;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->info(), output);
  }
  
}

int LogonRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ver = 1;
    if (has_ver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ver());
    }
    
    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional bytes info = 3;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->info());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogonRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LogonRequest*>(&from));
}

void LogonRequest::MergeFrom(const LogonRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ver()) {
      set_ver(from.ver());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_info()) {
      set_info(from.info());
    }
  }
}

void LogonRequest::CopyFrom(const LogonRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogonRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void LogonRequest::Swap(LogonRequest* other) {
  if (other != this) {
    std::swap(ver_, other->ver_);
    std::swap(name_, other->name_);
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LogonRequest::GetTypeName() const {
  return "aggregator.LogonRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int LogonResponse::kSessionIdFieldNumber;
const int LogonResponse::kInfoFieldNumber;
#endif  // !_MSC_VER

LogonResponse::LogonResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LogonResponse::InitAsDefaultInstance() {
}

LogonResponse::LogonResponse(const LogonResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LogonResponse::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogonResponse::~LogonResponse() {
  SharedDtor();
}

void LogonResponse::SharedDtor() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LogonResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LogonResponse& LogonResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

LogonResponse* LogonResponse::default_instance_ = NULL;

LogonResponse* LogonResponse::New() const {
  return new LogonResponse;
}

void LogonResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    session_id_ = GOOGLE_ULONGLONG(0);
    if (has_info()) {
      if (info_ != &::google::protobuf::internal::kEmptyString) {
        info_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LogonResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_info;
        break;
      }
      
      // optional bytes info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogonResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }
  
  // optional bytes info = 2;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->info(), output);
  }
  
}

int LogonResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }
    
    // optional bytes info = 2;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->info());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogonResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LogonResponse*>(&from));
}

void LogonResponse::MergeFrom(const LogonResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_info()) {
      set_info(from.info());
    }
  }
}

void LogonResponse::CopyFrom(const LogonResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogonResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void LogonResponse::Swap(LogonResponse* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LogonResponse::GetTypeName() const {
  return "aggregator.LogonResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int LogoutRequest::kMsgFieldNumber;
#endif  // !_MSC_VER

LogoutRequest::LogoutRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LogoutRequest::InitAsDefaultInstance() {
}

LogoutRequest::LogoutRequest(const LogoutRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LogoutRequest::SharedCtor() {
  _cached_size_ = 0;
  msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogoutRequest::~LogoutRequest() {
  SharedDtor();
}

void LogoutRequest::SharedDtor() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LogoutRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LogoutRequest& LogoutRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

LogoutRequest* LogoutRequest::default_instance_ = NULL;

LogoutRequest* LogoutRequest::New() const {
  return new LogoutRequest;
}

void LogoutRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_msg()) {
      if (msg_ != &::google::protobuf::internal::kEmptyString) {
        msg_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LogoutRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string msg = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogoutRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string msg = 1;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->msg(), output);
  }
  
}

int LogoutRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string msg = 1;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogoutRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LogoutRequest*>(&from));
}

void LogoutRequest::MergeFrom(const LogoutRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg()) {
      set_msg(from.msg());
    }
  }
}

void LogoutRequest::CopyFrom(const LogoutRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogoutRequest::IsInitialized() const {
  
  return true;
}

void LogoutRequest::Swap(LogoutRequest* other) {
  if (other != this) {
    std::swap(msg_, other->msg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LogoutRequest::GetTypeName() const {
  return "aggregator.LogoutRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int KeepAliveRequest::kSyncPosFieldNumber;
const int KeepAliveRequest::kMsgFieldNumber;
#endif  // !_MSC_VER

KeepAliveRequest::KeepAliveRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void KeepAliveRequest::InitAsDefaultInstance() {
}

KeepAliveRequest::KeepAliveRequest(const KeepAliveRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void KeepAliveRequest::SharedCtor() {
  _cached_size_ = 0;
  sync_pos_ = GOOGLE_ULONGLONG(0);
  msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeepAliveRequest::~KeepAliveRequest() {
  SharedDtor();
}

void KeepAliveRequest::SharedDtor() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void KeepAliveRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const KeepAliveRequest& KeepAliveRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

KeepAliveRequest* KeepAliveRequest::default_instance_ = NULL;

KeepAliveRequest* KeepAliveRequest::New() const {
  return new KeepAliveRequest;
}

void KeepAliveRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sync_pos_ = GOOGLE_ULONGLONG(0);
    if (has_msg()) {
      if (msg_ != &::google::protobuf::internal::kEmptyString) {
        msg_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool KeepAliveRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 sync_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sync_pos_)));
          set_has_sync_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_msg;
        break;
      }
      
      // optional string msg = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeepAliveRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 sync_pos = 1;
  if (has_sync_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sync_pos(), output);
  }
  
  // optional string msg = 2;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->msg(), output);
  }
  
}

int KeepAliveRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 sync_pos = 1;
    if (has_sync_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sync_pos());
    }
    
    // optional string msg = 2;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeepAliveRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const KeepAliveRequest*>(&from));
}

void KeepAliveRequest::MergeFrom(const KeepAliveRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sync_pos()) {
      set_sync_pos(from.sync_pos());
    }
    if (from.has_msg()) {
      set_msg(from.msg());
    }
  }
}

void KeepAliveRequest::CopyFrom(const KeepAliveRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeepAliveRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void KeepAliveRequest::Swap(KeepAliveRequest* other) {
  if (other != this) {
    std::swap(sync_pos_, other->sync_pos_);
    std::swap(msg_, other->msg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string KeepAliveRequest::GetTypeName() const {
  return "aggregator.KeepAliveRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int KeepAliveResponse::kSyncPosFieldNumber;
const int KeepAliveResponse::kMsgFieldNumber;
#endif  // !_MSC_VER

KeepAliveResponse::KeepAliveResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void KeepAliveResponse::InitAsDefaultInstance() {
}

KeepAliveResponse::KeepAliveResponse(const KeepAliveResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void KeepAliveResponse::SharedCtor() {
  _cached_size_ = 0;
  sync_pos_ = GOOGLE_ULONGLONG(0);
  msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeepAliveResponse::~KeepAliveResponse() {
  SharedDtor();
}

void KeepAliveResponse::SharedDtor() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void KeepAliveResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const KeepAliveResponse& KeepAliveResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

KeepAliveResponse* KeepAliveResponse::default_instance_ = NULL;

KeepAliveResponse* KeepAliveResponse::New() const {
  return new KeepAliveResponse;
}

void KeepAliveResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sync_pos_ = GOOGLE_ULONGLONG(0);
    if (has_msg()) {
      if (msg_ != &::google::protobuf::internal::kEmptyString) {
        msg_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool KeepAliveResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 sync_pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sync_pos_)));
          set_has_sync_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_msg;
        break;
      }
      
      // optional string msg = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeepAliveResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 sync_pos = 1;
  if (has_sync_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sync_pos(), output);
  }
  
  // optional string msg = 2;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->msg(), output);
  }
  
}

int KeepAliveResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 sync_pos = 1;
    if (has_sync_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sync_pos());
    }
    
    // optional string msg = 2;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeepAliveResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const KeepAliveResponse*>(&from));
}

void KeepAliveResponse::MergeFrom(const KeepAliveResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sync_pos()) {
      set_sync_pos(from.sync_pos());
    }
    if (from.has_msg()) {
      set_msg(from.msg());
    }
  }
}

void KeepAliveResponse::CopyFrom(const KeepAliveResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeepAliveResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void KeepAliveResponse::Swap(KeepAliveResponse* other) {
  if (other != this) {
    std::swap(sync_pos_, other->sync_pos_);
    std::swap(msg_, other->msg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string KeepAliveResponse::GetTypeName() const {
  return "aggregator.KeepAliveResponse";
}


// ===================================================================

bool InstructResponse_EncodeType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const InstructResponse_EncodeType InstructResponse::CollectNow;
const InstructResponse_EncodeType InstructResponse::SlowDown;
const InstructResponse_EncodeType InstructResponse::EncodeType_MIN;
const InstructResponse_EncodeType InstructResponse::EncodeType_MAX;
const int InstructResponse::EncodeType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int InstructResponse::kInstructionFieldNumber;
#endif  // !_MSC_VER

InstructResponse::InstructResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void InstructResponse::InitAsDefaultInstance() {
}

InstructResponse::InstructResponse(const InstructResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void InstructResponse::SharedCtor() {
  _cached_size_ = 0;
  instruction_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InstructResponse::~InstructResponse() {
  SharedDtor();
}

void InstructResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void InstructResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InstructResponse& InstructResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

InstructResponse* InstructResponse::default_instance_ = NULL;

InstructResponse* InstructResponse::New() const {
  return new InstructResponse;
}

void InstructResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    instruction_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool InstructResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 instruction = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &instruction_)));
          set_has_instruction();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InstructResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 instruction = 1;
  if (has_instruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->instruction(), output);
  }
  
}

int InstructResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 instruction = 1;
    if (has_instruction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->instruction());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InstructResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InstructResponse*>(&from));
}

void InstructResponse::MergeFrom(const InstructResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_instruction()) {
      set_instruction(from.instruction());
    }
  }
}

void InstructResponse::CopyFrom(const InstructResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstructResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void InstructResponse::Swap(InstructResponse* other) {
  if (other != this) {
    std::swap(instruction_, other->instruction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string InstructResponse::GetTypeName() const {
  return "aggregator.InstructResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int TransID::kIdFieldNumber;
#endif  // !_MSC_VER

TransID::TransID()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TransID::InitAsDefaultInstance() {
}

TransID::TransID(const TransID& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TransID::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransID::~TransID() {
  SharedDtor();
}

void TransID::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TransID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransID& TransID::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

TransID* TransID::default_instance_ = NULL;

TransID* TransID::New() const {
  return new TransID;
}

void TransID::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TransID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }
  
}

int TransID::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransID::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransID*>(&from));
}

void TransID::MergeFrom(const TransID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
}

void TransID::CopyFrom(const TransID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void TransID::Swap(TransID* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TransID::GetTypeName() const {
  return "aggregator.TransID";
}


// ===================================================================

#ifndef _MSC_VER
const int CollectorRequest::kSessionIdFieldNumber;
const int CollectorRequest::kTrxidRequestFieldNumber;
const int CollectorRequest::kLogonRequestFieldNumber;
const int CollectorRequest::kLogoutRequestFieldNumber;
const int CollectorRequest::kKeepaliveRequestFieldNumber;
const int CollectorRequest::kLogRequestFieldNumber;
const int CollectorRequest::kConfigRequestFieldNumber;
const int CollectorRequest::kCollectorfileRequestFieldNumber;
const int CollectorRequest::kCollectruleRequestFieldNumber;
const int CollectorRequest::kFileRequestFieldNumber;
const int CollectorRequest::kFiledataRequestFieldNumber;
const int CollectorRequest::kChecksumRequestFieldNumber;
#endif  // !_MSC_VER

CollectorRequest::CollectorRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CollectorRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  trxid_request_ = const_cast< ::aggregator::TransID*>(
      ::aggregator::TransID::internal_default_instance());
#else
  trxid_request_ = const_cast< ::aggregator::TransID*>(&::aggregator::TransID::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  logon_request_ = const_cast< ::aggregator::LogonRequest*>(
      ::aggregator::LogonRequest::internal_default_instance());
#else
  logon_request_ = const_cast< ::aggregator::LogonRequest*>(&::aggregator::LogonRequest::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  logout_request_ = const_cast< ::aggregator::LogoutRequest*>(
      ::aggregator::LogoutRequest::internal_default_instance());
#else
  logout_request_ = const_cast< ::aggregator::LogoutRequest*>(&::aggregator::LogoutRequest::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  keepalive_request_ = const_cast< ::aggregator::KeepAliveRequest*>(
      ::aggregator::KeepAliveRequest::internal_default_instance());
#else
  keepalive_request_ = const_cast< ::aggregator::KeepAliveRequest*>(&::aggregator::KeepAliveRequest::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  log_request_ = const_cast< ::aggregator::LogRequest*>(
      ::aggregator::LogRequest::internal_default_instance());
#else
  log_request_ = const_cast< ::aggregator::LogRequest*>(&::aggregator::LogRequest::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  config_request_ = const_cast< ::aggregator::ConfigRequest*>(
      ::aggregator::ConfigRequest::internal_default_instance());
#else
  config_request_ = const_cast< ::aggregator::ConfigRequest*>(&::aggregator::ConfigRequest::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  collectorfile_request_ = const_cast< ::aggregator::CollectorFileRequest*>(
      ::aggregator::CollectorFileRequest::internal_default_instance());
#else
  collectorfile_request_ = const_cast< ::aggregator::CollectorFileRequest*>(&::aggregator::CollectorFileRequest::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  collectrule_request_ = const_cast< ::aggregator::CollectRuleRequest*>(
      ::aggregator::CollectRuleRequest::internal_default_instance());
#else
  collectrule_request_ = const_cast< ::aggregator::CollectRuleRequest*>(&::aggregator::CollectRuleRequest::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  file_request_ = const_cast< ::aggregator::FileRequest*>(
      ::aggregator::FileRequest::internal_default_instance());
#else
  file_request_ = const_cast< ::aggregator::FileRequest*>(&::aggregator::FileRequest::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  filedata_request_ = const_cast< ::aggregator::FileDataRequest*>(
      ::aggregator::FileDataRequest::internal_default_instance());
#else
  filedata_request_ = const_cast< ::aggregator::FileDataRequest*>(&::aggregator::FileDataRequest::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  checksum_request_ = const_cast< ::aggregator::CheckSumRequest*>(
      ::aggregator::CheckSumRequest::internal_default_instance());
#else
  checksum_request_ = const_cast< ::aggregator::CheckSumRequest*>(&::aggregator::CheckSumRequest::default_instance());
#endif
}

CollectorRequest::CollectorRequest(const CollectorRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CollectorRequest::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  trxid_request_ = NULL;
  logon_request_ = NULL;
  logout_request_ = NULL;
  keepalive_request_ = NULL;
  log_request_ = NULL;
  config_request_ = NULL;
  collectorfile_request_ = NULL;
  collectrule_request_ = NULL;
  file_request_ = NULL;
  filedata_request_ = NULL;
  checksum_request_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectorRequest::~CollectorRequest() {
  SharedDtor();
}

void CollectorRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete trxid_request_;
    delete logon_request_;
    delete logout_request_;
    delete keepalive_request_;
    delete log_request_;
    delete config_request_;
    delete collectorfile_request_;
    delete collectrule_request_;
    delete file_request_;
    delete filedata_request_;
    delete checksum_request_;
  }
}

void CollectorRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CollectorRequest& CollectorRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

CollectorRequest* CollectorRequest::default_instance_ = NULL;

CollectorRequest* CollectorRequest::New() const {
  return new CollectorRequest;
}

void CollectorRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    session_id_ = GOOGLE_ULONGLONG(0);
    if (has_trxid_request()) {
      if (trxid_request_ != NULL) trxid_request_->::aggregator::TransID::Clear();
    }
    if (has_logon_request()) {
      if (logon_request_ != NULL) logon_request_->::aggregator::LogonRequest::Clear();
    }
    if (has_logout_request()) {
      if (logout_request_ != NULL) logout_request_->::aggregator::LogoutRequest::Clear();
    }
    if (has_keepalive_request()) {
      if (keepalive_request_ != NULL) keepalive_request_->::aggregator::KeepAliveRequest::Clear();
    }
    if (has_log_request()) {
      if (log_request_ != NULL) log_request_->::aggregator::LogRequest::Clear();
    }
    if (has_config_request()) {
      if (config_request_ != NULL) config_request_->::aggregator::ConfigRequest::Clear();
    }
    if (has_collectorfile_request()) {
      if (collectorfile_request_ != NULL) collectorfile_request_->::aggregator::CollectorFileRequest::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_collectrule_request()) {
      if (collectrule_request_ != NULL) collectrule_request_->::aggregator::CollectRuleRequest::Clear();
    }
    if (has_file_request()) {
      if (file_request_ != NULL) file_request_->::aggregator::FileRequest::Clear();
    }
    if (has_filedata_request()) {
      if (filedata_request_ != NULL) filedata_request_->::aggregator::FileDataRequest::Clear();
    }
    if (has_checksum_request()) {
      if (checksum_request_ != NULL) checksum_request_->::aggregator::CheckSumRequest::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CollectorRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_trxid_request;
        break;
      }
      
      // optional .aggregator.TransID trxid_request = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_trxid_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trxid_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_logon_request;
        break;
      }
      
      // optional .aggregator.LogonRequest logon_request = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_logon_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_logon_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_logout_request;
        break;
      }
      
      // optional .aggregator.LogoutRequest logout_request = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_logout_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_logout_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_keepalive_request;
        break;
      }
      
      // optional .aggregator.KeepAliveRequest keepalive_request = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_keepalive_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_keepalive_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_log_request;
        break;
      }
      
      // optional .aggregator.LogRequest log_request = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_log_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_log_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_config_request;
        break;
      }
      
      // optional .aggregator.ConfigRequest config_request = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_config_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_collectorfile_request;
        break;
      }
      
      // optional .aggregator.CollectorFileRequest collectorfile_request = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_collectorfile_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collectorfile_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_collectrule_request;
        break;
      }
      
      // optional .aggregator.CollectRuleRequest collectrule_request = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_collectrule_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collectrule_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_file_request;
        break;
      }
      
      // optional .aggregator.FileRequest file_request = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_file_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_filedata_request;
        break;
      }
      
      // optional .aggregator.FileDataRequest filedata_request = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filedata_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filedata_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_checksum_request;
        break;
      }
      
      // optional .aggregator.CheckSumRequest checksum_request = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_checksum_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_checksum_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollectorRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }
  
  // optional .aggregator.TransID trxid_request = 3;
  if (has_trxid_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->trxid_request(), output);
  }
  
  // optional .aggregator.LogonRequest logon_request = 5;
  if (has_logon_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->logon_request(), output);
  }
  
  // optional .aggregator.LogoutRequest logout_request = 6;
  if (has_logout_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->logout_request(), output);
  }
  
  // optional .aggregator.KeepAliveRequest keepalive_request = 7;
  if (has_keepalive_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->keepalive_request(), output);
  }
  
  // optional .aggregator.LogRequest log_request = 8;
  if (has_log_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->log_request(), output);
  }
  
  // optional .aggregator.ConfigRequest config_request = 10;
  if (has_config_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->config_request(), output);
  }
  
  // optional .aggregator.CollectorFileRequest collectorfile_request = 11;
  if (has_collectorfile_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->collectorfile_request(), output);
  }
  
  // optional .aggregator.CollectRuleRequest collectrule_request = 12;
  if (has_collectrule_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12, this->collectrule_request(), output);
  }
  
  // optional .aggregator.FileRequest file_request = 13;
  if (has_file_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, this->file_request(), output);
  }
  
  // optional .aggregator.FileDataRequest filedata_request = 14;
  if (has_filedata_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      14, this->filedata_request(), output);
  }
  
  // optional .aggregator.CheckSumRequest checksum_request = 15;
  if (has_checksum_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, this->checksum_request(), output);
  }
  
}

int CollectorRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }
    
    // optional .aggregator.TransID trxid_request = 3;
    if (has_trxid_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->trxid_request());
    }
    
    // optional .aggregator.LogonRequest logon_request = 5;
    if (has_logon_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->logon_request());
    }
    
    // optional .aggregator.LogoutRequest logout_request = 6;
    if (has_logout_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->logout_request());
    }
    
    // optional .aggregator.KeepAliveRequest keepalive_request = 7;
    if (has_keepalive_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->keepalive_request());
    }
    
    // optional .aggregator.LogRequest log_request = 8;
    if (has_log_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->log_request());
    }
    
    // optional .aggregator.ConfigRequest config_request = 10;
    if (has_config_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->config_request());
    }
    
    // optional .aggregator.CollectorFileRequest collectorfile_request = 11;
    if (has_collectorfile_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->collectorfile_request());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .aggregator.CollectRuleRequest collectrule_request = 12;
    if (has_collectrule_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->collectrule_request());
    }
    
    // optional .aggregator.FileRequest file_request = 13;
    if (has_file_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->file_request());
    }
    
    // optional .aggregator.FileDataRequest filedata_request = 14;
    if (has_filedata_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filedata_request());
    }
    
    // optional .aggregator.CheckSumRequest checksum_request = 15;
    if (has_checksum_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->checksum_request());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectorRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CollectorRequest*>(&from));
}

void CollectorRequest::MergeFrom(const CollectorRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_trxid_request()) {
      mutable_trxid_request()->::aggregator::TransID::MergeFrom(from.trxid_request());
    }
    if (from.has_logon_request()) {
      mutable_logon_request()->::aggregator::LogonRequest::MergeFrom(from.logon_request());
    }
    if (from.has_logout_request()) {
      mutable_logout_request()->::aggregator::LogoutRequest::MergeFrom(from.logout_request());
    }
    if (from.has_keepalive_request()) {
      mutable_keepalive_request()->::aggregator::KeepAliveRequest::MergeFrom(from.keepalive_request());
    }
    if (from.has_log_request()) {
      mutable_log_request()->::aggregator::LogRequest::MergeFrom(from.log_request());
    }
    if (from.has_config_request()) {
      mutable_config_request()->::aggregator::ConfigRequest::MergeFrom(from.config_request());
    }
    if (from.has_collectorfile_request()) {
      mutable_collectorfile_request()->::aggregator::CollectorFileRequest::MergeFrom(from.collectorfile_request());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_collectrule_request()) {
      mutable_collectrule_request()->::aggregator::CollectRuleRequest::MergeFrom(from.collectrule_request());
    }
    if (from.has_file_request()) {
      mutable_file_request()->::aggregator::FileRequest::MergeFrom(from.file_request());
    }
    if (from.has_filedata_request()) {
      mutable_filedata_request()->::aggregator::FileDataRequest::MergeFrom(from.filedata_request());
    }
    if (from.has_checksum_request()) {
      mutable_checksum_request()->::aggregator::CheckSumRequest::MergeFrom(from.checksum_request());
    }
  }
}

void CollectorRequest::CopyFrom(const CollectorRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectorRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_trxid_request()) {
    if (!this->trxid_request().IsInitialized()) return false;
  }
  if (has_logon_request()) {
    if (!this->logon_request().IsInitialized()) return false;
  }
  if (has_keepalive_request()) {
    if (!this->keepalive_request().IsInitialized()) return false;
  }
  if (has_log_request()) {
    if (!this->log_request().IsInitialized()) return false;
  }
  if (has_file_request()) {
    if (!this->file_request().IsInitialized()) return false;
  }
  if (has_filedata_request()) {
    if (!this->filedata_request().IsInitialized()) return false;
  }
  if (has_checksum_request()) {
    if (!this->checksum_request().IsInitialized()) return false;
  }
  return true;
}

void CollectorRequest::Swap(CollectorRequest* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(trxid_request_, other->trxid_request_);
    std::swap(logon_request_, other->logon_request_);
    std::swap(logout_request_, other->logout_request_);
    std::swap(keepalive_request_, other->keepalive_request_);
    std::swap(log_request_, other->log_request_);
    std::swap(config_request_, other->config_request_);
    std::swap(collectorfile_request_, other->collectorfile_request_);
    std::swap(collectrule_request_, other->collectrule_request_);
    std::swap(file_request_, other->file_request_);
    std::swap(filedata_request_, other->filedata_request_);
    std::swap(checksum_request_, other->checksum_request_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CollectorRequest::GetTypeName() const {
  return "aggregator.CollectorRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int AggregatorResponse::kErrorCodeFieldNumber;
const int AggregatorResponse::kErrorMessageFieldNumber;
const int AggregatorResponse::kTrxidResponseFieldNumber;
const int AggregatorResponse::kLogonResponseFieldNumber;
const int AggregatorResponse::kKeepaliveResponseFieldNumber;
const int AggregatorResponse::kLogResponseFieldNumber;
const int AggregatorResponse::kConfigResponseFieldNumber;
const int AggregatorResponse::kCollectorfileResponseFieldNumber;
const int AggregatorResponse::kCollectruleResponseFieldNumber;
const int AggregatorResponse::kFileResponseFieldNumber;
const int AggregatorResponse::kFiledataResponseFieldNumber;
const int AggregatorResponse::kChecksumResponseFieldNumber;
const int AggregatorResponse::kInstructResponseFieldNumber;
#endif  // !_MSC_VER

AggregatorResponse::AggregatorResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AggregatorResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  trxid_response_ = const_cast< ::aggregator::TransID*>(
      ::aggregator::TransID::internal_default_instance());
#else
  trxid_response_ = const_cast< ::aggregator::TransID*>(&::aggregator::TransID::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  logon_response_ = const_cast< ::aggregator::LogonResponse*>(
      ::aggregator::LogonResponse::internal_default_instance());
#else
  logon_response_ = const_cast< ::aggregator::LogonResponse*>(&::aggregator::LogonResponse::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  keepalive_response_ = const_cast< ::aggregator::KeepAliveResponse*>(
      ::aggregator::KeepAliveResponse::internal_default_instance());
#else
  keepalive_response_ = const_cast< ::aggregator::KeepAliveResponse*>(&::aggregator::KeepAliveResponse::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  log_response_ = const_cast< ::aggregator::LogResponse*>(
      ::aggregator::LogResponse::internal_default_instance());
#else
  log_response_ = const_cast< ::aggregator::LogResponse*>(&::aggregator::LogResponse::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  config_response_ = const_cast< ::aggregator::ConfigResponse*>(
      ::aggregator::ConfigResponse::internal_default_instance());
#else
  config_response_ = const_cast< ::aggregator::ConfigResponse*>(&::aggregator::ConfigResponse::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  collectorfile_response_ = const_cast< ::aggregator::CollectorFileResponse*>(
      ::aggregator::CollectorFileResponse::internal_default_instance());
#else
  collectorfile_response_ = const_cast< ::aggregator::CollectorFileResponse*>(&::aggregator::CollectorFileResponse::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  collectrule_response_ = const_cast< ::aggregator::CollectRuleResponse*>(
      ::aggregator::CollectRuleResponse::internal_default_instance());
#else
  collectrule_response_ = const_cast< ::aggregator::CollectRuleResponse*>(&::aggregator::CollectRuleResponse::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  file_response_ = const_cast< ::aggregator::FileResponse*>(
      ::aggregator::FileResponse::internal_default_instance());
#else
  file_response_ = const_cast< ::aggregator::FileResponse*>(&::aggregator::FileResponse::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  filedata_response_ = const_cast< ::aggregator::FileDataResponse*>(
      ::aggregator::FileDataResponse::internal_default_instance());
#else
  filedata_response_ = const_cast< ::aggregator::FileDataResponse*>(&::aggregator::FileDataResponse::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  checksum_response_ = const_cast< ::aggregator::CheckSumResponse*>(
      ::aggregator::CheckSumResponse::internal_default_instance());
#else
  checksum_response_ = const_cast< ::aggregator::CheckSumResponse*>(&::aggregator::CheckSumResponse::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  instruct_response_ = const_cast< ::aggregator::InstructResponse*>(
      ::aggregator::InstructResponse::internal_default_instance());
#else
  instruct_response_ = const_cast< ::aggregator::InstructResponse*>(&::aggregator::InstructResponse::default_instance());
#endif
}

AggregatorResponse::AggregatorResponse(const AggregatorResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AggregatorResponse::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0u;
  error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  trxid_response_ = NULL;
  logon_response_ = NULL;
  keepalive_response_ = NULL;
  log_response_ = NULL;
  config_response_ = NULL;
  collectorfile_response_ = NULL;
  collectrule_response_ = NULL;
  file_response_ = NULL;
  filedata_response_ = NULL;
  checksum_response_ = NULL;
  instruct_response_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AggregatorResponse::~AggregatorResponse() {
  SharedDtor();
}

void AggregatorResponse::SharedDtor() {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    delete error_message_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete trxid_response_;
    delete logon_response_;
    delete keepalive_response_;
    delete log_response_;
    delete config_response_;
    delete collectorfile_response_;
    delete collectrule_response_;
    delete file_response_;
    delete filedata_response_;
    delete checksum_response_;
    delete instruct_response_;
  }
}

void AggregatorResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AggregatorResponse& AggregatorResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_aggregator_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_aggregator_2eproto();
#endif
  return *default_instance_;
}

AggregatorResponse* AggregatorResponse::default_instance_ = NULL;

AggregatorResponse* AggregatorResponse::New() const {
  return new AggregatorResponse;
}

void AggregatorResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0u;
    if (has_error_message()) {
      if (error_message_ != &::google::protobuf::internal::kEmptyString) {
        error_message_->clear();
      }
    }
    if (has_trxid_response()) {
      if (trxid_response_ != NULL) trxid_response_->::aggregator::TransID::Clear();
    }
    if (has_logon_response()) {
      if (logon_response_ != NULL) logon_response_->::aggregator::LogonResponse::Clear();
    }
    if (has_keepalive_response()) {
      if (keepalive_response_ != NULL) keepalive_response_->::aggregator::KeepAliveResponse::Clear();
    }
    if (has_log_response()) {
      if (log_response_ != NULL) log_response_->::aggregator::LogResponse::Clear();
    }
    if (has_config_response()) {
      if (config_response_ != NULL) config_response_->::aggregator::ConfigResponse::Clear();
    }
    if (has_collectorfile_response()) {
      if (collectorfile_response_ != NULL) collectorfile_response_->::aggregator::CollectorFileResponse::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_collectrule_response()) {
      if (collectrule_response_ != NULL) collectrule_response_->::aggregator::CollectRuleResponse::Clear();
    }
    if (has_file_response()) {
      if (file_response_ != NULL) file_response_->::aggregator::FileResponse::Clear();
    }
    if (has_filedata_response()) {
      if (filedata_response_ != NULL) filedata_response_->::aggregator::FileDataResponse::Clear();
    }
    if (has_checksum_response()) {
      if (checksum_response_ != NULL) checksum_response_->::aggregator::CheckSumResponse::Clear();
    }
    if (has_instruct_response()) {
      if (instruct_response_ != NULL) instruct_response_->::aggregator::InstructResponse::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AggregatorResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_error_message;
        break;
      }
      
      // optional string error_message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_error_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_error_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_trxid_response;
        break;
      }
      
      // optional .aggregator.TransID trxid_response = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_trxid_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trxid_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_logon_response;
        break;
      }
      
      // optional .aggregator.LogonResponse logon_response = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_logon_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_logon_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_keepalive_response;
        break;
      }
      
      // optional .aggregator.KeepAliveResponse keepalive_response = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_keepalive_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_keepalive_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_log_response;
        break;
      }
      
      // optional .aggregator.LogResponse log_response = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_log_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_log_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_config_response;
        break;
      }
      
      // optional .aggregator.ConfigResponse config_response = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_config_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_collectorfile_response;
        break;
      }
      
      // optional .aggregator.CollectorFileResponse collectorfile_response = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_collectorfile_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collectorfile_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_collectrule_response;
        break;
      }
      
      // optional .aggregator.CollectRuleResponse collectrule_response = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_collectrule_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collectrule_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_file_response;
        break;
      }
      
      // optional .aggregator.FileResponse file_response = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_file_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_filedata_response;
        break;
      }
      
      // optional .aggregator.FileDataResponse filedata_response = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filedata_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filedata_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_checksum_response;
        break;
      }
      
      // optional .aggregator.CheckSumResponse checksum_response = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_checksum_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_checksum_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_instruct_response;
        break;
      }
      
      // optional .aggregator.InstructResponse instruct_response = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_instruct_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_instruct_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AggregatorResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->error_code(), output);
  }
  
  // optional string error_message = 2;
  if (has_error_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->error_message(), output);
  }
  
  // optional .aggregator.TransID trxid_response = 3;
  if (has_trxid_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->trxid_response(), output);
  }
  
  // optional .aggregator.LogonResponse logon_response = 5;
  if (has_logon_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->logon_response(), output);
  }
  
  // optional .aggregator.KeepAliveResponse keepalive_response = 7;
  if (has_keepalive_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->keepalive_response(), output);
  }
  
  // optional .aggregator.LogResponse log_response = 8;
  if (has_log_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->log_response(), output);
  }
  
  // optional .aggregator.ConfigResponse config_response = 10;
  if (has_config_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->config_response(), output);
  }
  
  // optional .aggregator.CollectorFileResponse collectorfile_response = 11;
  if (has_collectorfile_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->collectorfile_response(), output);
  }
  
  // optional .aggregator.CollectRuleResponse collectrule_response = 12;
  if (has_collectrule_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12, this->collectrule_response(), output);
  }
  
  // optional .aggregator.FileResponse file_response = 13;
  if (has_file_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, this->file_response(), output);
  }
  
  // optional .aggregator.FileDataResponse filedata_response = 14;
  if (has_filedata_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      14, this->filedata_response(), output);
  }
  
  // optional .aggregator.CheckSumResponse checksum_response = 15;
  if (has_checksum_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, this->checksum_response(), output);
  }
  
  // optional .aggregator.InstructResponse instruct_response = 16;
  if (has_instruct_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      16, this->instruct_response(), output);
  }
  
}

int AggregatorResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_code());
    }
    
    // optional string error_message = 2;
    if (has_error_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->error_message());
    }
    
    // optional .aggregator.TransID trxid_response = 3;
    if (has_trxid_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->trxid_response());
    }
    
    // optional .aggregator.LogonResponse logon_response = 5;
    if (has_logon_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->logon_response());
    }
    
    // optional .aggregator.KeepAliveResponse keepalive_response = 7;
    if (has_keepalive_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->keepalive_response());
    }
    
    // optional .aggregator.LogResponse log_response = 8;
    if (has_log_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->log_response());
    }
    
    // optional .aggregator.ConfigResponse config_response = 10;
    if (has_config_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->config_response());
    }
    
    // optional .aggregator.CollectorFileResponse collectorfile_response = 11;
    if (has_collectorfile_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->collectorfile_response());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .aggregator.CollectRuleResponse collectrule_response = 12;
    if (has_collectrule_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->collectrule_response());
    }
    
    // optional .aggregator.FileResponse file_response = 13;
    if (has_file_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->file_response());
    }
    
    // optional .aggregator.FileDataResponse filedata_response = 14;
    if (has_filedata_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filedata_response());
    }
    
    // optional .aggregator.CheckSumResponse checksum_response = 15;
    if (has_checksum_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->checksum_response());
    }
    
    // optional .aggregator.InstructResponse instruct_response = 16;
    if (has_instruct_response()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->instruct_response());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AggregatorResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AggregatorResponse*>(&from));
}

void AggregatorResponse::MergeFrom(const AggregatorResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_error_message()) {
      set_error_message(from.error_message());
    }
    if (from.has_trxid_response()) {
      mutable_trxid_response()->::aggregator::TransID::MergeFrom(from.trxid_response());
    }
    if (from.has_logon_response()) {
      mutable_logon_response()->::aggregator::LogonResponse::MergeFrom(from.logon_response());
    }
    if (from.has_keepalive_response()) {
      mutable_keepalive_response()->::aggregator::KeepAliveResponse::MergeFrom(from.keepalive_response());
    }
    if (from.has_log_response()) {
      mutable_log_response()->::aggregator::LogResponse::MergeFrom(from.log_response());
    }
    if (from.has_config_response()) {
      mutable_config_response()->::aggregator::ConfigResponse::MergeFrom(from.config_response());
    }
    if (from.has_collectorfile_response()) {
      mutable_collectorfile_response()->::aggregator::CollectorFileResponse::MergeFrom(from.collectorfile_response());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_collectrule_response()) {
      mutable_collectrule_response()->::aggregator::CollectRuleResponse::MergeFrom(from.collectrule_response());
    }
    if (from.has_file_response()) {
      mutable_file_response()->::aggregator::FileResponse::MergeFrom(from.file_response());
    }
    if (from.has_filedata_response()) {
      mutable_filedata_response()->::aggregator::FileDataResponse::MergeFrom(from.filedata_response());
    }
    if (from.has_checksum_response()) {
      mutable_checksum_response()->::aggregator::CheckSumResponse::MergeFrom(from.checksum_response());
    }
    if (from.has_instruct_response()) {
      mutable_instruct_response()->::aggregator::InstructResponse::MergeFrom(from.instruct_response());
    }
  }
}

void AggregatorResponse::CopyFrom(const AggregatorResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AggregatorResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_trxid_response()) {
    if (!this->trxid_response().IsInitialized()) return false;
  }
  if (has_logon_response()) {
    if (!this->logon_response().IsInitialized()) return false;
  }
  if (has_keepalive_response()) {
    if (!this->keepalive_response().IsInitialized()) return false;
  }
  if (has_config_response()) {
    if (!this->config_response().IsInitialized()) return false;
  }
  if (has_collectorfile_response()) {
    if (!this->collectorfile_response().IsInitialized()) return false;
  }
  if (has_collectrule_response()) {
    if (!this->collectrule_response().IsInitialized()) return false;
  }
  if (has_file_response()) {
    if (!this->file_response().IsInitialized()) return false;
  }
  if (has_filedata_response()) {
    if (!this->filedata_response().IsInitialized()) return false;
  }
  if (has_checksum_response()) {
    if (!this->checksum_response().IsInitialized()) return false;
  }
  if (has_instruct_response()) {
    if (!this->instruct_response().IsInitialized()) return false;
  }
  return true;
}

void AggregatorResponse::Swap(AggregatorResponse* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(error_message_, other->error_message_);
    std::swap(trxid_response_, other->trxid_response_);
    std::swap(logon_response_, other->logon_response_);
    std::swap(keepalive_response_, other->keepalive_response_);
    std::swap(log_response_, other->log_response_);
    std::swap(config_response_, other->config_response_);
    std::swap(collectorfile_response_, other->collectorfile_response_);
    std::swap(collectrule_response_, other->collectrule_response_);
    std::swap(file_response_, other->file_response_);
    std::swap(filedata_response_, other->filedata_response_);
    std::swap(checksum_response_, other->checksum_response_);
    std::swap(instruct_response_, other->instruct_response_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AggregatorResponse::GetTypeName() const {
  return "aggregator.AggregatorResponse";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace aggregator

// @@protoc_insertion_point(global_scope)
