// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: aggregator.proto

#ifndef PROTOBUF_aggregator_2eproto__INCLUDED
#define PROTOBUF_aggregator_2eproto__INCLUDED

#ifdef _MSC_VER
# pragma warning(push)
# pragma warning(disable: 4244 4127)
#endif /* _MSC_VER */
#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace aggregator {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_aggregator_2eproto();
void protobuf_AssignDesc_aggregator_2eproto();
void protobuf_ShutdownFile_aggregator_2eproto();

class FileID;
class CheckSumRequest;
class CheckSumResponse;
class LogRequest;
class LogResponse;
class FileRequest;
class FileRequest_File;
class FileResponse;
class FileResponse_File;
class FileDataRequest;
class FileDataRequest_FileData;
class FileDataResponse;
class FileDataResponse_FileData;
class CollectorFileRequest;
class CollectorFileResponse;
class CollectorFileResponse_File;
class CollectRuleRequest;
class CollectRuleResponse;
class CollectRuleResponse_Rule;
class ConfigRequest;
class ConfigResponse;
class ConfigResponse_Time;
class LogonRequest;
class LogonResponse;
class LogoutRequest;
class KeepAliveRequest;
class KeepAliveResponse;
class InstructResponse;
class TransID;
class CollectorRequest;
class AggregatorResponse;

enum FileDataRequest_FileData_EncodeType {
  FileDataRequest_FileData_EncodeType_NONE = 0,
  FileDataRequest_FileData_EncodeType_DEFLATE = 1
};
bool FileDataRequest_FileData_EncodeType_IsValid(int value);
const FileDataRequest_FileData_EncodeType FileDataRequest_FileData_EncodeType_EncodeType_MIN = FileDataRequest_FileData_EncodeType_NONE;
const FileDataRequest_FileData_EncodeType FileDataRequest_FileData_EncodeType_EncodeType_MAX = FileDataRequest_FileData_EncodeType_DEFLATE;
const int FileDataRequest_FileData_EncodeType_EncodeType_ARRAYSIZE = FileDataRequest_FileData_EncodeType_EncodeType_MAX + 1;

enum FileDataResponse_FileData_FileStatus {
  FileDataResponse_FileData_FileStatus_PROCESS = 0,
  FileDataResponse_FileData_FileStatus_FINISH = 1
};
bool FileDataResponse_FileData_FileStatus_IsValid(int value);
const FileDataResponse_FileData_FileStatus FileDataResponse_FileData_FileStatus_FileStatus_MIN = FileDataResponse_FileData_FileStatus_PROCESS;
const FileDataResponse_FileData_FileStatus FileDataResponse_FileData_FileStatus_FileStatus_MAX = FileDataResponse_FileData_FileStatus_FINISH;
const int FileDataResponse_FileData_FileStatus_FileStatus_ARRAYSIZE = FileDataResponse_FileData_FileStatus_FileStatus_MAX + 1;

enum InstructResponse_EncodeType {
  InstructResponse_EncodeType_CollectNow = 1,
  InstructResponse_EncodeType_SlowDown = 2
};
bool InstructResponse_EncodeType_IsValid(int value);
const InstructResponse_EncodeType InstructResponse_EncodeType_EncodeType_MIN = InstructResponse_EncodeType_CollectNow;
const InstructResponse_EncodeType InstructResponse_EncodeType_EncodeType_MAX = InstructResponse_EncodeType_SlowDown;
const int InstructResponse_EncodeType_EncodeType_ARRAYSIZE = InstructResponse_EncodeType_EncodeType_MAX + 1;

// ===================================================================

class FileID : public ::google::protobuf::MessageLite {
 public:
  FileID();
  virtual ~FileID();
  
  FileID(const FileID& from);
  
  inline FileID& operator=(const FileID& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FileID& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileID* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(FileID* other);
  
  // implements Message ----------------------------------------------
  
  FileID* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileID& from);
  void MergeFrom(const FileID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:aggregator.FileID)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static FileID* default_instance_;
};
// -------------------------------------------------------------------

class CheckSumRequest : public ::google::protobuf::MessageLite {
 public:
  CheckSumRequest();
  virtual ~CheckSumRequest();
  
  CheckSumRequest(const CheckSumRequest& from);
  
  inline CheckSumRequest& operator=(const CheckSumRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CheckSumRequest& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CheckSumRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(CheckSumRequest* other);
  
  // implements Message ----------------------------------------------
  
  CheckSumRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CheckSumRequest& from);
  void MergeFrom(const CheckSumRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .aggregator.FileID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::aggregator::FileID& id() const;
  inline ::aggregator::FileID* mutable_id();
  inline ::aggregator::FileID* release_id();
  
  // required uint32 fb_cs_pos = 2;
  inline bool has_fb_cs_pos() const;
  inline void clear_fb_cs_pos();
  static const int kFbCsPosFieldNumber = 2;
  inline ::google::protobuf::uint32 fb_cs_pos() const;
  inline void set_fb_cs_pos(::google::protobuf::uint32 value);
  
  // required uint32 fb_cs_count = 3;
  inline bool has_fb_cs_count() const;
  inline void clear_fb_cs_count();
  static const int kFbCsCountFieldNumber = 3;
  inline ::google::protobuf::uint32 fb_cs_count() const;
  inline void set_fb_cs_count(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:aggregator.CheckSumRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_fb_cs_pos();
  inline void clear_has_fb_cs_pos();
  inline void set_has_fb_cs_count();
  inline void clear_has_fb_cs_count();
  
  ::aggregator::FileID* id_;
  ::google::protobuf::uint32 fb_cs_pos_;
  ::google::protobuf::uint32 fb_cs_count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static CheckSumRequest* default_instance_;
};
// -------------------------------------------------------------------

class CheckSumResponse : public ::google::protobuf::MessageLite {
 public:
  CheckSumResponse();
  virtual ~CheckSumResponse();
  
  CheckSumResponse(const CheckSumResponse& from);
  
  inline CheckSumResponse& operator=(const CheckSumResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CheckSumResponse& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CheckSumResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(CheckSumResponse* other);
  
  // implements Message ----------------------------------------------
  
  CheckSumResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CheckSumResponse& from);
  void MergeFrom(const CheckSumResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .aggregator.FileID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::aggregator::FileID& id() const;
  inline ::aggregator::FileID* mutable_id();
  inline ::aggregator::FileID* release_id();
  
  // required uint32 fb_cs_pos = 2;
  inline bool has_fb_cs_pos() const;
  inline void clear_fb_cs_pos();
  static const int kFbCsPosFieldNumber = 2;
  inline ::google::protobuf::uint32 fb_cs_pos() const;
  inline void set_fb_cs_pos(::google::protobuf::uint32 value);
  
  // required uint32 fb_cs_count = 3;
  inline bool has_fb_cs_count() const;
  inline void clear_fb_cs_count();
  static const int kFbCsCountFieldNumber = 3;
  inline ::google::protobuf::uint32 fb_cs_count() const;
  inline void set_fb_cs_count(::google::protobuf::uint32 value);
  
  // optional bytes fb_cs_data = 4;
  inline bool has_fb_cs_data() const;
  inline void clear_fb_cs_data();
  static const int kFbCsDataFieldNumber = 4;
  inline const ::std::string& fb_cs_data() const;
  inline void set_fb_cs_data(const ::std::string& value);
  inline void set_fb_cs_data(const char* value);
  inline void set_fb_cs_data(const void* value, size_t size);
  inline ::std::string* mutable_fb_cs_data();
  inline ::std::string* release_fb_cs_data();
  
  // @@protoc_insertion_point(class_scope:aggregator.CheckSumResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_fb_cs_pos();
  inline void clear_has_fb_cs_pos();
  inline void set_has_fb_cs_count();
  inline void clear_has_fb_cs_count();
  inline void set_has_fb_cs_data();
  inline void clear_has_fb_cs_data();
  
  ::aggregator::FileID* id_;
  ::google::protobuf::uint32 fb_cs_pos_;
  ::google::protobuf::uint32 fb_cs_count_;
  ::std::string* fb_cs_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static CheckSumResponse* default_instance_;
};
// -------------------------------------------------------------------

class LogRequest : public ::google::protobuf::MessageLite {
 public:
  LogRequest();
  virtual ~LogRequest();
  
  LogRequest(const LogRequest& from);
  
  inline LogRequest& operator=(const LogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const LogRequest& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(LogRequest* other);
  
  // implements Message ----------------------------------------------
  
  LogRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogRequest& from);
  void MergeFrom(const LogRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // required string data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // optional bytes content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // @@protoc_insertion_point(class_scope:aggregator.LogRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_content();
  inline void clear_has_content();
  
  ::std::string* data_;
  ::std::string* content_;
  ::google::protobuf::uint32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static LogRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogResponse : public ::google::protobuf::MessageLite {
 public:
  LogResponse();
  virtual ~LogResponse();
  
  LogResponse(const LogResponse& from);
  
  inline LogResponse& operator=(const LogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const LogResponse& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(LogResponse* other);
  
  // implements Message ----------------------------------------------
  
  LogResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogResponse& from);
  void MergeFrom(const LogResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:aggregator.LogResponse)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static LogResponse* default_instance_;
};
// -------------------------------------------------------------------

class FileRequest_File : public ::google::protobuf::MessageLite {
 public:
  FileRequest_File();
  virtual ~FileRequest_File();
  
  FileRequest_File(const FileRequest_File& from);
  
  inline FileRequest_File& operator=(const FileRequest_File& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FileRequest_File& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileRequest_File* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(FileRequest_File* other);
  
  // implements Message ----------------------------------------------
  
  FileRequest_File* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileRequest_File& from);
  void MergeFrom(const FileRequest_File& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string dir = 1;
  inline bool has_dir() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 1;
  inline const ::std::string& dir() const;
  inline void set_dir(const ::std::string& value);
  inline void set_dir(const char* value);
  inline void set_dir(const char* value, size_t size);
  inline ::std::string* mutable_dir();
  inline ::std::string* release_dir();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required uint64 ctime = 3;
  inline bool has_ctime() const;
  inline void clear_ctime();
  static const int kCtimeFieldNumber = 3;
  inline ::google::protobuf::uint64 ctime() const;
  inline void set_ctime(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:aggregator.FileRequest.File)
 private:
  inline void set_has_dir();
  inline void clear_has_dir();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ctime();
  inline void clear_has_ctime();
  
  ::std::string* dir_;
  ::std::string* name_;
  ::google::protobuf::uint64 ctime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static FileRequest_File* default_instance_;
};
// -------------------------------------------------------------------

class FileRequest : public ::google::protobuf::MessageLite {
 public:
  FileRequest();
  virtual ~FileRequest();
  
  FileRequest(const FileRequest& from);
  
  inline FileRequest& operator=(const FileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FileRequest& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(FileRequest* other);
  
  // implements Message ----------------------------------------------
  
  FileRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileRequest& from);
  void MergeFrom(const FileRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef FileRequest_File File;
  
  // accessors -------------------------------------------------------
  
  // repeated group File = 1 {
  inline int file_size() const;
  inline void clear_file();
  static const int kFileFieldNumber = 1;
  inline const ::aggregator::FileRequest_File& file(int index) const;
  inline ::aggregator::FileRequest_File* mutable_file(int index);
  inline ::aggregator::FileRequest_File* add_file();
  inline const ::google::protobuf::RepeatedPtrField< ::aggregator::FileRequest_File >&
      file() const;
  inline ::google::protobuf::RepeatedPtrField< ::aggregator::FileRequest_File >*
      mutable_file();
  
  // @@protoc_insertion_point(class_scope:aggregator.FileRequest)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::aggregator::FileRequest_File > file_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static FileRequest* default_instance_;
};
// -------------------------------------------------------------------

class FileResponse_File : public ::google::protobuf::MessageLite {
 public:
  FileResponse_File();
  virtual ~FileResponse_File();
  
  FileResponse_File(const FileResponse_File& from);
  
  inline FileResponse_File& operator=(const FileResponse_File& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FileResponse_File& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileResponse_File* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(FileResponse_File* other);
  
  // implements Message ----------------------------------------------
  
  FileResponse_File* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileResponse_File& from);
  void MergeFrom(const FileResponse_File& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .aggregator.FileID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::aggregator::FileID& id() const;
  inline ::aggregator::FileID* mutable_id();
  inline ::aggregator::FileID* release_id();
  
  // required string dir = 2;
  inline bool has_dir() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 2;
  inline const ::std::string& dir() const;
  inline void set_dir(const ::std::string& value);
  inline void set_dir(const char* value);
  inline void set_dir(const char* value, size_t size);
  inline ::std::string* mutable_dir();
  inline ::std::string* release_dir();
  
  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:aggregator.FileResponse.File)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_dir();
  inline void clear_has_dir();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::aggregator::FileID* id_;
  ::std::string* dir_;
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static FileResponse_File* default_instance_;
};
// -------------------------------------------------------------------

class FileResponse : public ::google::protobuf::MessageLite {
 public:
  FileResponse();
  virtual ~FileResponse();
  
  FileResponse(const FileResponse& from);
  
  inline FileResponse& operator=(const FileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FileResponse& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(FileResponse* other);
  
  // implements Message ----------------------------------------------
  
  FileResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileResponse& from);
  void MergeFrom(const FileResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef FileResponse_File File;
  
  // accessors -------------------------------------------------------
  
  // repeated group File = 1 {
  inline int file_size() const;
  inline void clear_file();
  static const int kFileFieldNumber = 1;
  inline const ::aggregator::FileResponse_File& file(int index) const;
  inline ::aggregator::FileResponse_File* mutable_file(int index);
  inline ::aggregator::FileResponse_File* add_file();
  inline const ::google::protobuf::RepeatedPtrField< ::aggregator::FileResponse_File >&
      file() const;
  inline ::google::protobuf::RepeatedPtrField< ::aggregator::FileResponse_File >*
      mutable_file();
  
  // @@protoc_insertion_point(class_scope:aggregator.FileResponse)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::aggregator::FileResponse_File > file_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static FileResponse* default_instance_;
};
// -------------------------------------------------------------------

class FileDataRequest_FileData : public ::google::protobuf::MessageLite {
 public:
  FileDataRequest_FileData();
  virtual ~FileDataRequest_FileData();
  
  FileDataRequest_FileData(const FileDataRequest_FileData& from);
  
  inline FileDataRequest_FileData& operator=(const FileDataRequest_FileData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FileDataRequest_FileData& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileDataRequest_FileData* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(FileDataRequest_FileData* other);
  
  // implements Message ----------------------------------------------
  
  FileDataRequest_FileData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileDataRequest_FileData& from);
  void MergeFrom(const FileDataRequest_FileData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef FileDataRequest_FileData_EncodeType EncodeType;
  static const EncodeType NONE = FileDataRequest_FileData_EncodeType_NONE;
  static const EncodeType DEFLATE = FileDataRequest_FileData_EncodeType_DEFLATE;
  static inline bool EncodeType_IsValid(int value) {
    return FileDataRequest_FileData_EncodeType_IsValid(value);
  }
  static const EncodeType EncodeType_MIN =
    FileDataRequest_FileData_EncodeType_EncodeType_MIN;
  static const EncodeType EncodeType_MAX =
    FileDataRequest_FileData_EncodeType_EncodeType_MAX;
  static const int EncodeType_ARRAYSIZE =
    FileDataRequest_FileData_EncodeType_EncodeType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .aggregator.FileID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::aggregator::FileID& id() const;
  inline ::aggregator::FileID* mutable_id();
  inline ::aggregator::FileID* release_id();
  
  // required uint64 pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline ::google::protobuf::uint64 pos() const;
  inline void set_pos(::google::protobuf::uint64 value);
  
  // required .aggregator.FileDataRequest.FileData.EncodeType encode = 3 [default = NONE];
  inline bool has_encode() const;
  inline void clear_encode();
  static const int kEncodeFieldNumber = 3;
  inline ::aggregator::FileDataRequest_FileData_EncodeType encode() const;
  inline void set_encode(::aggregator::FileDataRequest_FileData_EncodeType value);
  
  // optional uint32 org_len = 4;
  inline bool has_org_len() const;
  inline void clear_org_len();
  static const int kOrgLenFieldNumber = 4;
  inline ::google::protobuf::uint32 org_len() const;
  inline void set_org_len(::google::protobuf::uint32 value);
  
  // required bytes data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:aggregator.FileDataRequest.FileData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_encode();
  inline void clear_has_encode();
  inline void set_has_org_len();
  inline void clear_has_org_len();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::aggregator::FileID* id_;
  ::google::protobuf::uint64 pos_;
  int encode_;
  ::google::protobuf::uint32 org_len_;
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static FileDataRequest_FileData* default_instance_;
};
// -------------------------------------------------------------------

class FileDataRequest : public ::google::protobuf::MessageLite {
 public:
  FileDataRequest();
  virtual ~FileDataRequest();
  
  FileDataRequest(const FileDataRequest& from);
  
  inline FileDataRequest& operator=(const FileDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FileDataRequest& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileDataRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(FileDataRequest* other);
  
  // implements Message ----------------------------------------------
  
  FileDataRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileDataRequest& from);
  void MergeFrom(const FileDataRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef FileDataRequest_FileData FileData;
  
  // accessors -------------------------------------------------------
  
  // repeated group FileData = 1 {
  inline int filedata_size() const;
  inline void clear_filedata();
  static const int kFiledataFieldNumber = 1;
  inline const ::aggregator::FileDataRequest_FileData& filedata(int index) const;
  inline ::aggregator::FileDataRequest_FileData* mutable_filedata(int index);
  inline ::aggregator::FileDataRequest_FileData* add_filedata();
  inline const ::google::protobuf::RepeatedPtrField< ::aggregator::FileDataRequest_FileData >&
      filedata() const;
  inline ::google::protobuf::RepeatedPtrField< ::aggregator::FileDataRequest_FileData >*
      mutable_filedata();
  
  // @@protoc_insertion_point(class_scope:aggregator.FileDataRequest)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::aggregator::FileDataRequest_FileData > filedata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static FileDataRequest* default_instance_;
};
// -------------------------------------------------------------------

class FileDataResponse_FileData : public ::google::protobuf::MessageLite {
 public:
  FileDataResponse_FileData();
  virtual ~FileDataResponse_FileData();
  
  FileDataResponse_FileData(const FileDataResponse_FileData& from);
  
  inline FileDataResponse_FileData& operator=(const FileDataResponse_FileData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FileDataResponse_FileData& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileDataResponse_FileData* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(FileDataResponse_FileData* other);
  
  // implements Message ----------------------------------------------
  
  FileDataResponse_FileData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileDataResponse_FileData& from);
  void MergeFrom(const FileDataResponse_FileData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef FileDataResponse_FileData_FileStatus FileStatus;
  static const FileStatus PROCESS = FileDataResponse_FileData_FileStatus_PROCESS;
  static const FileStatus FINISH = FileDataResponse_FileData_FileStatus_FINISH;
  static inline bool FileStatus_IsValid(int value) {
    return FileDataResponse_FileData_FileStatus_IsValid(value);
  }
  static const FileStatus FileStatus_MIN =
    FileDataResponse_FileData_FileStatus_FileStatus_MIN;
  static const FileStatus FileStatus_MAX =
    FileDataResponse_FileData_FileStatus_FileStatus_MAX;
  static const int FileStatus_ARRAYSIZE =
    FileDataResponse_FileData_FileStatus_FileStatus_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .aggregator.FileID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::aggregator::FileID& id() const;
  inline ::aggregator::FileID* mutable_id();
  inline ::aggregator::FileID* release_id();
  
  // required uint64 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);
  
  // optional .aggregator.FileDataResponse.FileData.FileStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::aggregator::FileDataResponse_FileData_FileStatus status() const;
  inline void set_status(::aggregator::FileDataResponse_FileData_FileStatus value);
  
  // optional string checksum = 4;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kChecksumFieldNumber = 4;
  inline const ::std::string& checksum() const;
  inline void set_checksum(const ::std::string& value);
  inline void set_checksum(const char* value);
  inline void set_checksum(const char* value, size_t size);
  inline ::std::string* mutable_checksum();
  inline ::std::string* release_checksum();
  
  // @@protoc_insertion_point(class_scope:aggregator.FileDataResponse.FileData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_checksum();
  inline void clear_has_checksum();
  
  ::aggregator::FileID* id_;
  ::google::protobuf::uint64 size_;
  ::std::string* checksum_;
  int status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static FileDataResponse_FileData* default_instance_;
};
// -------------------------------------------------------------------

class FileDataResponse : public ::google::protobuf::MessageLite {
 public:
  FileDataResponse();
  virtual ~FileDataResponse();
  
  FileDataResponse(const FileDataResponse& from);
  
  inline FileDataResponse& operator=(const FileDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const FileDataResponse& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileDataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(FileDataResponse* other);
  
  // implements Message ----------------------------------------------
  
  FileDataResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileDataResponse& from);
  void MergeFrom(const FileDataResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef FileDataResponse_FileData FileData;
  
  // accessors -------------------------------------------------------
  
  // repeated group FileData = 1 {
  inline int filedata_size() const;
  inline void clear_filedata();
  static const int kFiledataFieldNumber = 1;
  inline const ::aggregator::FileDataResponse_FileData& filedata(int index) const;
  inline ::aggregator::FileDataResponse_FileData* mutable_filedata(int index);
  inline ::aggregator::FileDataResponse_FileData* add_filedata();
  inline const ::google::protobuf::RepeatedPtrField< ::aggregator::FileDataResponse_FileData >&
      filedata() const;
  inline ::google::protobuf::RepeatedPtrField< ::aggregator::FileDataResponse_FileData >*
      mutable_filedata();
  
  // @@protoc_insertion_point(class_scope:aggregator.FileDataResponse)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::aggregator::FileDataResponse_FileData > filedata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static FileDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class CollectorFileRequest : public ::google::protobuf::MessageLite {
 public:
  CollectorFileRequest();
  virtual ~CollectorFileRequest();
  
  CollectorFileRequest(const CollectorFileRequest& from);
  
  inline CollectorFileRequest& operator=(const CollectorFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CollectorFileRequest& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CollectorFileRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(CollectorFileRequest* other);
  
  // implements Message ----------------------------------------------
  
  CollectorFileRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CollectorFileRequest& from);
  void MergeFrom(const CollectorFileRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:aggregator.CollectorFileRequest)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static CollectorFileRequest* default_instance_;
};
// -------------------------------------------------------------------

class CollectorFileResponse_File : public ::google::protobuf::MessageLite {
 public:
  CollectorFileResponse_File();
  virtual ~CollectorFileResponse_File();
  
  CollectorFileResponse_File(const CollectorFileResponse_File& from);
  
  inline CollectorFileResponse_File& operator=(const CollectorFileResponse_File& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CollectorFileResponse_File& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CollectorFileResponse_File* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(CollectorFileResponse_File* other);
  
  // implements Message ----------------------------------------------
  
  CollectorFileResponse_File* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CollectorFileResponse_File& from);
  void MergeFrom(const CollectorFileResponse_File& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .aggregator.FileID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::aggregator::FileID& id() const;
  inline ::aggregator::FileID* mutable_id();
  inline ::aggregator::FileID* release_id();
  
  // required uint64 pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline ::google::protobuf::uint64 pos() const;
  inline void set_pos(::google::protobuf::uint64 value);
  
  // required bool finish = 3;
  inline bool has_finish() const;
  inline void clear_finish();
  static const int kFinishFieldNumber = 3;
  inline bool finish() const;
  inline void set_finish(bool value);
  
  // required string dir = 4;
  inline bool has_dir() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 4;
  inline const ::std::string& dir() const;
  inline void set_dir(const ::std::string& value);
  inline void set_dir(const char* value);
  inline void set_dir(const char* value, size_t size);
  inline ::std::string* mutable_dir();
  inline ::std::string* release_dir();
  
  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:aggregator.CollectorFileResponse.File)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_finish();
  inline void clear_has_finish();
  inline void set_has_dir();
  inline void clear_has_dir();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::aggregator::FileID* id_;
  ::google::protobuf::uint64 pos_;
  ::std::string* dir_;
  ::std::string* name_;
  bool finish_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static CollectorFileResponse_File* default_instance_;
};
// -------------------------------------------------------------------

class CollectorFileResponse : public ::google::protobuf::MessageLite {
 public:
  CollectorFileResponse();
  virtual ~CollectorFileResponse();
  
  CollectorFileResponse(const CollectorFileResponse& from);
  
  inline CollectorFileResponse& operator=(const CollectorFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CollectorFileResponse& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CollectorFileResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(CollectorFileResponse* other);
  
  // implements Message ----------------------------------------------
  
  CollectorFileResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CollectorFileResponse& from);
  void MergeFrom(const CollectorFileResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef CollectorFileResponse_File File;
  
  // accessors -------------------------------------------------------
  
  // repeated group File = 1 {
  inline int file_size() const;
  inline void clear_file();
  static const int kFileFieldNumber = 1;
  inline const ::aggregator::CollectorFileResponse_File& file(int index) const;
  inline ::aggregator::CollectorFileResponse_File* mutable_file(int index);
  inline ::aggregator::CollectorFileResponse_File* add_file();
  inline const ::google::protobuf::RepeatedPtrField< ::aggregator::CollectorFileResponse_File >&
      file() const;
  inline ::google::protobuf::RepeatedPtrField< ::aggregator::CollectorFileResponse_File >*
      mutable_file();
  
  // @@protoc_insertion_point(class_scope:aggregator.CollectorFileResponse)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::aggregator::CollectorFileResponse_File > file_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static CollectorFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class CollectRuleRequest : public ::google::protobuf::MessageLite {
 public:
  CollectRuleRequest();
  virtual ~CollectRuleRequest();
  
  CollectRuleRequest(const CollectRuleRequest& from);
  
  inline CollectRuleRequest& operator=(const CollectRuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CollectRuleRequest& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CollectRuleRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(CollectRuleRequest* other);
  
  // implements Message ----------------------------------------------
  
  CollectRuleRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CollectRuleRequest& from);
  void MergeFrom(const CollectRuleRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:aggregator.CollectRuleRequest)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static CollectRuleRequest* default_instance_;
};
// -------------------------------------------------------------------

class CollectRuleResponse_Rule : public ::google::protobuf::MessageLite {
 public:
  CollectRuleResponse_Rule();
  virtual ~CollectRuleResponse_Rule();
  
  CollectRuleResponse_Rule(const CollectRuleResponse_Rule& from);
  
  inline CollectRuleResponse_Rule& operator=(const CollectRuleResponse_Rule& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CollectRuleResponse_Rule& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CollectRuleResponse_Rule* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(CollectRuleResponse_Rule* other);
  
  // implements Message ----------------------------------------------
  
  CollectRuleResponse_Rule* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CollectRuleResponse_Rule& from);
  void MergeFrom(const CollectRuleResponse_Rule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string dir = 1;
  inline bool has_dir() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 1;
  inline const ::std::string& dir() const;
  inline void set_dir(const ::std::string& value);
  inline void set_dir(const char* value);
  inline void set_dir(const char* value, size_t size);
  inline ::std::string* mutable_dir();
  inline ::std::string* release_dir();
  
  // optional string exclude = 2;
  inline bool has_exclude() const;
  inline void clear_exclude();
  static const int kExcludeFieldNumber = 2;
  inline const ::std::string& exclude() const;
  inline void set_exclude(const ::std::string& value);
  inline void set_exclude(const char* value);
  inline void set_exclude(const char* value, size_t size);
  inline ::std::string* mutable_exclude();
  inline ::std::string* release_exclude();
  
  // required string include = 3;
  inline bool has_include() const;
  inline void clear_include();
  static const int kIncludeFieldNumber = 3;
  inline const ::std::string& include() const;
  inline void set_include(const ::std::string& value);
  inline void set_include(const char* value);
  inline void set_include(const char* value, size_t size);
  inline ::std::string* mutable_include();
  inline ::std::string* release_include();
  
  // @@protoc_insertion_point(class_scope:aggregator.CollectRuleResponse.Rule)
 private:
  inline void set_has_dir();
  inline void clear_has_dir();
  inline void set_has_exclude();
  inline void clear_has_exclude();
  inline void set_has_include();
  inline void clear_has_include();
  
  ::std::string* dir_;
  ::std::string* exclude_;
  ::std::string* include_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static CollectRuleResponse_Rule* default_instance_;
};
// -------------------------------------------------------------------

class CollectRuleResponse : public ::google::protobuf::MessageLite {
 public:
  CollectRuleResponse();
  virtual ~CollectRuleResponse();
  
  CollectRuleResponse(const CollectRuleResponse& from);
  
  inline CollectRuleResponse& operator=(const CollectRuleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CollectRuleResponse& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CollectRuleResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(CollectRuleResponse* other);
  
  // implements Message ----------------------------------------------
  
  CollectRuleResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CollectRuleResponse& from);
  void MergeFrom(const CollectRuleResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef CollectRuleResponse_Rule Rule;
  
  // accessors -------------------------------------------------------
  
  // repeated group Rule = 1 {
  inline int rule_size() const;
  inline void clear_rule();
  static const int kRuleFieldNumber = 1;
  inline const ::aggregator::CollectRuleResponse_Rule& rule(int index) const;
  inline ::aggregator::CollectRuleResponse_Rule* mutable_rule(int index);
  inline ::aggregator::CollectRuleResponse_Rule* add_rule();
  inline const ::google::protobuf::RepeatedPtrField< ::aggregator::CollectRuleResponse_Rule >&
      rule() const;
  inline ::google::protobuf::RepeatedPtrField< ::aggregator::CollectRuleResponse_Rule >*
      mutable_rule();
  
  // @@protoc_insertion_point(class_scope:aggregator.CollectRuleResponse)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::aggregator::CollectRuleResponse_Rule > rule_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static CollectRuleResponse* default_instance_;
};
// -------------------------------------------------------------------

class ConfigRequest : public ::google::protobuf::MessageLite {
 public:
  ConfigRequest();
  virtual ~ConfigRequest();
  
  ConfigRequest(const ConfigRequest& from);
  
  inline ConfigRequest& operator=(const ConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ConfigRequest& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(ConfigRequest* other);
  
  // implements Message ----------------------------------------------
  
  ConfigRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigRequest& from);
  void MergeFrom(const ConfigRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:aggregator.ConfigRequest)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static ConfigRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConfigResponse_Time : public ::google::protobuf::MessageLite {
 public:
  ConfigResponse_Time();
  virtual ~ConfigResponse_Time();
  
  ConfigResponse_Time(const ConfigResponse_Time& from);
  
  inline ConfigResponse_Time& operator=(const ConfigResponse_Time& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ConfigResponse_Time& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigResponse_Time* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(ConfigResponse_Time* other);
  
  // implements Message ----------------------------------------------
  
  ConfigResponse_Time* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigResponse_Time& from);
  void MergeFrom(const ConfigResponse_Time& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 no = 1;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 1;
  inline ::google::protobuf::uint32 no() const;
  inline void set_no(::google::protobuf::uint32 value);
  
  // required uint32 keepalive = 2;
  inline bool has_keepalive() const;
  inline void clear_keepalive();
  static const int kKeepaliveFieldNumber = 2;
  inline ::google::protobuf::uint32 keepalive() const;
  inline void set_keepalive(::google::protobuf::uint32 value);
  
  // required uint32 rate = 3;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 3;
  inline ::google::protobuf::uint32 rate() const;
  inline void set_rate(::google::protobuf::uint32 value);
  
  // required uint32 start = 4;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 4;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);
  
  // required uint32 end = 5;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 5;
  inline ::google::protobuf::uint32 end() const;
  inline void set_end(::google::protobuf::uint32 value);
  
  // required uint32 steptime = 6;
  inline bool has_steptime() const;
  inline void clear_steptime();
  static const int kSteptimeFieldNumber = 6;
  inline ::google::protobuf::uint32 steptime() const;
  inline void set_steptime(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:aggregator.ConfigResponse.Time)
 private:
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_keepalive();
  inline void clear_has_keepalive();
  inline void set_has_rate();
  inline void clear_has_rate();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_steptime();
  inline void clear_has_steptime();
  
  ::google::protobuf::uint32 no_;
  ::google::protobuf::uint32 keepalive_;
  ::google::protobuf::uint32 rate_;
  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 end_;
  ::google::protobuf::uint32 steptime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static ConfigResponse_Time* default_instance_;
};
// -------------------------------------------------------------------

class ConfigResponse : public ::google::protobuf::MessageLite {
 public:
  ConfigResponse();
  virtual ~ConfigResponse();
  
  ConfigResponse(const ConfigResponse& from);
  
  inline ConfigResponse& operator=(const ConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ConfigResponse& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(ConfigResponse* other);
  
  // implements Message ----------------------------------------------
  
  ConfigResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigResponse& from);
  void MergeFrom(const ConfigResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ConfigResponse_Time Time;
  
  // accessors -------------------------------------------------------
  
  // repeated group Time = 1 {
  inline int time_size() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline const ::aggregator::ConfigResponse_Time& time(int index) const;
  inline ::aggregator::ConfigResponse_Time* mutable_time(int index);
  inline ::aggregator::ConfigResponse_Time* add_time();
  inline const ::google::protobuf::RepeatedPtrField< ::aggregator::ConfigResponse_Time >&
      time() const;
  inline ::google::protobuf::RepeatedPtrField< ::aggregator::ConfigResponse_Time >*
      mutable_time();
  
  // @@protoc_insertion_point(class_scope:aggregator.ConfigResponse)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::aggregator::ConfigResponse_Time > time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static ConfigResponse* default_instance_;
};
// -------------------------------------------------------------------

class LogonRequest : public ::google::protobuf::MessageLite {
 public:
  LogonRequest();
  virtual ~LogonRequest();
  
  LogonRequest(const LogonRequest& from);
  
  inline LogonRequest& operator=(const LogonRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const LogonRequest& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogonRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(LogonRequest* other);
  
  // implements Message ----------------------------------------------
  
  LogonRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogonRequest& from);
  void MergeFrom(const LogonRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 ver = 1;
  inline bool has_ver() const;
  inline void clear_ver();
  static const int kVerFieldNumber = 1;
  inline ::google::protobuf::uint32 ver() const;
  inline void set_ver(::google::protobuf::uint32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional bytes info = 3;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const void* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  
  // @@protoc_insertion_point(class_scope:aggregator.LogonRequest)
 private:
  inline void set_has_ver();
  inline void clear_has_ver();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_info();
  inline void clear_has_info();
  
  ::std::string* name_;
  ::std::string* info_;
  ::google::protobuf::uint32 ver_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static LogonRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogonResponse : public ::google::protobuf::MessageLite {
 public:
  LogonResponse();
  virtual ~LogonResponse();
  
  LogonResponse(const LogonResponse& from);
  
  inline LogonResponse& operator=(const LogonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const LogonResponse& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogonResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(LogonResponse* other);
  
  // implements Message ----------------------------------------------
  
  LogonResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogonResponse& from);
  void MergeFrom(const LogonResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);
  
  // optional bytes info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const void* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  
  // @@protoc_insertion_point(class_scope:aggregator.LogonResponse)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_info();
  inline void clear_has_info();
  
  ::google::protobuf::uint64 session_id_;
  ::std::string* info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static LogonResponse* default_instance_;
};
// -------------------------------------------------------------------

class LogoutRequest : public ::google::protobuf::MessageLite {
 public:
  LogoutRequest();
  virtual ~LogoutRequest();
  
  LogoutRequest(const LogoutRequest& from);
  
  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const LogoutRequest& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogoutRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(LogoutRequest* other);
  
  // implements Message ----------------------------------------------
  
  LogoutRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogoutRequest& from);
  void MergeFrom(const LogoutRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:aggregator.LogoutRequest)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::std::string* msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static LogoutRequest* default_instance_;
};
// -------------------------------------------------------------------

class KeepAliveRequest : public ::google::protobuf::MessageLite {
 public:
  KeepAliveRequest();
  virtual ~KeepAliveRequest();
  
  KeepAliveRequest(const KeepAliveRequest& from);
  
  inline KeepAliveRequest& operator=(const KeepAliveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const KeepAliveRequest& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KeepAliveRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(KeepAliveRequest* other);
  
  // implements Message ----------------------------------------------
  
  KeepAliveRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KeepAliveRequest& from);
  void MergeFrom(const KeepAliveRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 sync_pos = 1;
  inline bool has_sync_pos() const;
  inline void clear_sync_pos();
  static const int kSyncPosFieldNumber = 1;
  inline ::google::protobuf::uint64 sync_pos() const;
  inline void set_sync_pos(::google::protobuf::uint64 value);
  
  // optional string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:aggregator.KeepAliveRequest)
 private:
  inline void set_has_sync_pos();
  inline void clear_has_sync_pos();
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::uint64 sync_pos_;
  ::std::string* msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static KeepAliveRequest* default_instance_;
};
// -------------------------------------------------------------------

class KeepAliveResponse : public ::google::protobuf::MessageLite {
 public:
  KeepAliveResponse();
  virtual ~KeepAliveResponse();
  
  KeepAliveResponse(const KeepAliveResponse& from);
  
  inline KeepAliveResponse& operator=(const KeepAliveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const KeepAliveResponse& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KeepAliveResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(KeepAliveResponse* other);
  
  // implements Message ----------------------------------------------
  
  KeepAliveResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KeepAliveResponse& from);
  void MergeFrom(const KeepAliveResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 sync_pos = 1;
  inline bool has_sync_pos() const;
  inline void clear_sync_pos();
  static const int kSyncPosFieldNumber = 1;
  inline ::google::protobuf::uint64 sync_pos() const;
  inline void set_sync_pos(::google::protobuf::uint64 value);
  
  // optional string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:aggregator.KeepAliveResponse)
 private:
  inline void set_has_sync_pos();
  inline void clear_has_sync_pos();
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::uint64 sync_pos_;
  ::std::string* msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static KeepAliveResponse* default_instance_;
};
// -------------------------------------------------------------------

class InstructResponse : public ::google::protobuf::MessageLite {
 public:
  InstructResponse();
  virtual ~InstructResponse();
  
  InstructResponse(const InstructResponse& from);
  
  inline InstructResponse& operator=(const InstructResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const InstructResponse& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstructResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(InstructResponse* other);
  
  // implements Message ----------------------------------------------
  
  InstructResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstructResponse& from);
  void MergeFrom(const InstructResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef InstructResponse_EncodeType EncodeType;
  static const EncodeType CollectNow = InstructResponse_EncodeType_CollectNow;
  static const EncodeType SlowDown = InstructResponse_EncodeType_SlowDown;
  static inline bool EncodeType_IsValid(int value) {
    return InstructResponse_EncodeType_IsValid(value);
  }
  static const EncodeType EncodeType_MIN =
    InstructResponse_EncodeType_EncodeType_MIN;
  static const EncodeType EncodeType_MAX =
    InstructResponse_EncodeType_EncodeType_MAX;
  static const int EncodeType_ARRAYSIZE =
    InstructResponse_EncodeType_EncodeType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required uint32 instruction = 1;
  inline bool has_instruction() const;
  inline void clear_instruction();
  static const int kInstructionFieldNumber = 1;
  inline ::google::protobuf::uint32 instruction() const;
  inline void set_instruction(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:aggregator.InstructResponse)
 private:
  inline void set_has_instruction();
  inline void clear_has_instruction();
  
  ::google::protobuf::uint32 instruction_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static InstructResponse* default_instance_;
};
// -------------------------------------------------------------------

class TransID : public ::google::protobuf::MessageLite {
 public:
  TransID();
  virtual ~TransID();
  
  TransID(const TransID& from);
  
  inline TransID& operator=(const TransID& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const TransID& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransID* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(TransID* other);
  
  // implements Message ----------------------------------------------
  
  TransID* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransID& from);
  void MergeFrom(const TransID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:aggregator.TransID)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static TransID* default_instance_;
};
// -------------------------------------------------------------------

class CollectorRequest : public ::google::protobuf::MessageLite {
 public:
  CollectorRequest();
  virtual ~CollectorRequest();
  
  CollectorRequest(const CollectorRequest& from);
  
  inline CollectorRequest& operator=(const CollectorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CollectorRequest& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CollectorRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(CollectorRequest* other);
  
  // implements Message ----------------------------------------------
  
  CollectorRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CollectorRequest& from);
  void MergeFrom(const CollectorRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);
  
  // optional .aggregator.TransID trxid_request = 3;
  inline bool has_trxid_request() const;
  inline void clear_trxid_request();
  static const int kTrxidRequestFieldNumber = 3;
  inline const ::aggregator::TransID& trxid_request() const;
  inline ::aggregator::TransID* mutable_trxid_request();
  inline ::aggregator::TransID* release_trxid_request();
  
  // optional .aggregator.LogonRequest logon_request = 5;
  inline bool has_logon_request() const;
  inline void clear_logon_request();
  static const int kLogonRequestFieldNumber = 5;
  inline const ::aggregator::LogonRequest& logon_request() const;
  inline ::aggregator::LogonRequest* mutable_logon_request();
  inline ::aggregator::LogonRequest* release_logon_request();
  
  // optional .aggregator.LogoutRequest logout_request = 6;
  inline bool has_logout_request() const;
  inline void clear_logout_request();
  static const int kLogoutRequestFieldNumber = 6;
  inline const ::aggregator::LogoutRequest& logout_request() const;
  inline ::aggregator::LogoutRequest* mutable_logout_request();
  inline ::aggregator::LogoutRequest* release_logout_request();
  
  // optional .aggregator.KeepAliveRequest keepalive_request = 7;
  inline bool has_keepalive_request() const;
  inline void clear_keepalive_request();
  static const int kKeepaliveRequestFieldNumber = 7;
  inline const ::aggregator::KeepAliveRequest& keepalive_request() const;
  inline ::aggregator::KeepAliveRequest* mutable_keepalive_request();
  inline ::aggregator::KeepAliveRequest* release_keepalive_request();
  
  // optional .aggregator.LogRequest log_request = 8;
  inline bool has_log_request() const;
  inline void clear_log_request();
  static const int kLogRequestFieldNumber = 8;
  inline const ::aggregator::LogRequest& log_request() const;
  inline ::aggregator::LogRequest* mutable_log_request();
  inline ::aggregator::LogRequest* release_log_request();
  
  // optional .aggregator.ConfigRequest config_request = 10;
  inline bool has_config_request() const;
  inline void clear_config_request();
  static const int kConfigRequestFieldNumber = 10;
  inline const ::aggregator::ConfigRequest& config_request() const;
  inline ::aggregator::ConfigRequest* mutable_config_request();
  inline ::aggregator::ConfigRequest* release_config_request();
  
  // optional .aggregator.CollectorFileRequest collectorfile_request = 11;
  inline bool has_collectorfile_request() const;
  inline void clear_collectorfile_request();
  static const int kCollectorfileRequestFieldNumber = 11;
  inline const ::aggregator::CollectorFileRequest& collectorfile_request() const;
  inline ::aggregator::CollectorFileRequest* mutable_collectorfile_request();
  inline ::aggregator::CollectorFileRequest* release_collectorfile_request();
  
  // optional .aggregator.CollectRuleRequest collectrule_request = 12;
  inline bool has_collectrule_request() const;
  inline void clear_collectrule_request();
  static const int kCollectruleRequestFieldNumber = 12;
  inline const ::aggregator::CollectRuleRequest& collectrule_request() const;
  inline ::aggregator::CollectRuleRequest* mutable_collectrule_request();
  inline ::aggregator::CollectRuleRequest* release_collectrule_request();
  
  // optional .aggregator.FileRequest file_request = 13;
  inline bool has_file_request() const;
  inline void clear_file_request();
  static const int kFileRequestFieldNumber = 13;
  inline const ::aggregator::FileRequest& file_request() const;
  inline ::aggregator::FileRequest* mutable_file_request();
  inline ::aggregator::FileRequest* release_file_request();
  
  // optional .aggregator.FileDataRequest filedata_request = 14;
  inline bool has_filedata_request() const;
  inline void clear_filedata_request();
  static const int kFiledataRequestFieldNumber = 14;
  inline const ::aggregator::FileDataRequest& filedata_request() const;
  inline ::aggregator::FileDataRequest* mutable_filedata_request();
  inline ::aggregator::FileDataRequest* release_filedata_request();
  
  // optional .aggregator.CheckSumRequest checksum_request = 15;
  inline bool has_checksum_request() const;
  inline void clear_checksum_request();
  static const int kChecksumRequestFieldNumber = 15;
  inline const ::aggregator::CheckSumRequest& checksum_request() const;
  inline ::aggregator::CheckSumRequest* mutable_checksum_request();
  inline ::aggregator::CheckSumRequest* release_checksum_request();
  
  // @@protoc_insertion_point(class_scope:aggregator.CollectorRequest)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_trxid_request();
  inline void clear_has_trxid_request();
  inline void set_has_logon_request();
  inline void clear_has_logon_request();
  inline void set_has_logout_request();
  inline void clear_has_logout_request();
  inline void set_has_keepalive_request();
  inline void clear_has_keepalive_request();
  inline void set_has_log_request();
  inline void clear_has_log_request();
  inline void set_has_config_request();
  inline void clear_has_config_request();
  inline void set_has_collectorfile_request();
  inline void clear_has_collectorfile_request();
  inline void set_has_collectrule_request();
  inline void clear_has_collectrule_request();
  inline void set_has_file_request();
  inline void clear_has_file_request();
  inline void set_has_filedata_request();
  inline void clear_has_filedata_request();
  inline void set_has_checksum_request();
  inline void clear_has_checksum_request();
  
  ::google::protobuf::uint64 session_id_;
  ::aggregator::TransID* trxid_request_;
  ::aggregator::LogonRequest* logon_request_;
  ::aggregator::LogoutRequest* logout_request_;
  ::aggregator::KeepAliveRequest* keepalive_request_;
  ::aggregator::LogRequest* log_request_;
  ::aggregator::ConfigRequest* config_request_;
  ::aggregator::CollectorFileRequest* collectorfile_request_;
  ::aggregator::CollectRuleRequest* collectrule_request_;
  ::aggregator::FileRequest* file_request_;
  ::aggregator::FileDataRequest* filedata_request_;
  ::aggregator::CheckSumRequest* checksum_request_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static CollectorRequest* default_instance_;
};
// -------------------------------------------------------------------

class AggregatorResponse : public ::google::protobuf::MessageLite {
 public:
  AggregatorResponse();
  virtual ~AggregatorResponse();
  
  AggregatorResponse(const AggregatorResponse& from);
  
  inline AggregatorResponse& operator=(const AggregatorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AggregatorResponse& default_instance();
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AggregatorResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif
  
  void Swap(AggregatorResponse* other);
  
  // implements Message ----------------------------------------------
  
  AggregatorResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AggregatorResponse& from);
  void MergeFrom(const AggregatorResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 error_code() const;
  inline void set_error_code(::google::protobuf::uint32 value);
  
  // optional string error_message = 2;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  
  // optional .aggregator.TransID trxid_response = 3;
  inline bool has_trxid_response() const;
  inline void clear_trxid_response();
  static const int kTrxidResponseFieldNumber = 3;
  inline const ::aggregator::TransID& trxid_response() const;
  inline ::aggregator::TransID* mutable_trxid_response();
  inline ::aggregator::TransID* release_trxid_response();
  
  // optional .aggregator.LogonResponse logon_response = 5;
  inline bool has_logon_response() const;
  inline void clear_logon_response();
  static const int kLogonResponseFieldNumber = 5;
  inline const ::aggregator::LogonResponse& logon_response() const;
  inline ::aggregator::LogonResponse* mutable_logon_response();
  inline ::aggregator::LogonResponse* release_logon_response();
  
  // optional .aggregator.KeepAliveResponse keepalive_response = 7;
  inline bool has_keepalive_response() const;
  inline void clear_keepalive_response();
  static const int kKeepaliveResponseFieldNumber = 7;
  inline const ::aggregator::KeepAliveResponse& keepalive_response() const;
  inline ::aggregator::KeepAliveResponse* mutable_keepalive_response();
  inline ::aggregator::KeepAliveResponse* release_keepalive_response();
  
  // optional .aggregator.LogResponse log_response = 8;
  inline bool has_log_response() const;
  inline void clear_log_response();
  static const int kLogResponseFieldNumber = 8;
  inline const ::aggregator::LogResponse& log_response() const;
  inline ::aggregator::LogResponse* mutable_log_response();
  inline ::aggregator::LogResponse* release_log_response();
  
  // optional .aggregator.ConfigResponse config_response = 10;
  inline bool has_config_response() const;
  inline void clear_config_response();
  static const int kConfigResponseFieldNumber = 10;
  inline const ::aggregator::ConfigResponse& config_response() const;
  inline ::aggregator::ConfigResponse* mutable_config_response();
  inline ::aggregator::ConfigResponse* release_config_response();
  
  // optional .aggregator.CollectorFileResponse collectorfile_response = 11;
  inline bool has_collectorfile_response() const;
  inline void clear_collectorfile_response();
  static const int kCollectorfileResponseFieldNumber = 11;
  inline const ::aggregator::CollectorFileResponse& collectorfile_response() const;
  inline ::aggregator::CollectorFileResponse* mutable_collectorfile_response();
  inline ::aggregator::CollectorFileResponse* release_collectorfile_response();
  
  // optional .aggregator.CollectRuleResponse collectrule_response = 12;
  inline bool has_collectrule_response() const;
  inline void clear_collectrule_response();
  static const int kCollectruleResponseFieldNumber = 12;
  inline const ::aggregator::CollectRuleResponse& collectrule_response() const;
  inline ::aggregator::CollectRuleResponse* mutable_collectrule_response();
  inline ::aggregator::CollectRuleResponse* release_collectrule_response();
  
  // optional .aggregator.FileResponse file_response = 13;
  inline bool has_file_response() const;
  inline void clear_file_response();
  static const int kFileResponseFieldNumber = 13;
  inline const ::aggregator::FileResponse& file_response() const;
  inline ::aggregator::FileResponse* mutable_file_response();
  inline ::aggregator::FileResponse* release_file_response();
  
  // optional .aggregator.FileDataResponse filedata_response = 14;
  inline bool has_filedata_response() const;
  inline void clear_filedata_response();
  static const int kFiledataResponseFieldNumber = 14;
  inline const ::aggregator::FileDataResponse& filedata_response() const;
  inline ::aggregator::FileDataResponse* mutable_filedata_response();
  inline ::aggregator::FileDataResponse* release_filedata_response();
  
  // optional .aggregator.CheckSumResponse checksum_response = 15;
  inline bool has_checksum_response() const;
  inline void clear_checksum_response();
  static const int kChecksumResponseFieldNumber = 15;
  inline const ::aggregator::CheckSumResponse& checksum_response() const;
  inline ::aggregator::CheckSumResponse* mutable_checksum_response();
  inline ::aggregator::CheckSumResponse* release_checksum_response();
  
  // optional .aggregator.InstructResponse instruct_response = 16;
  inline bool has_instruct_response() const;
  inline void clear_instruct_response();
  static const int kInstructResponseFieldNumber = 16;
  inline const ::aggregator::InstructResponse& instruct_response() const;
  inline ::aggregator::InstructResponse* mutable_instruct_response();
  inline ::aggregator::InstructResponse* release_instruct_response();
  
  // @@protoc_insertion_point(class_scope:aggregator.AggregatorResponse)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_error_message();
  inline void clear_has_error_message();
  inline void set_has_trxid_response();
  inline void clear_has_trxid_response();
  inline void set_has_logon_response();
  inline void clear_has_logon_response();
  inline void set_has_keepalive_response();
  inline void clear_has_keepalive_response();
  inline void set_has_log_response();
  inline void clear_has_log_response();
  inline void set_has_config_response();
  inline void clear_has_config_response();
  inline void set_has_collectorfile_response();
  inline void clear_has_collectorfile_response();
  inline void set_has_collectrule_response();
  inline void clear_has_collectrule_response();
  inline void set_has_file_response();
  inline void clear_has_file_response();
  inline void set_has_filedata_response();
  inline void clear_has_filedata_response();
  inline void set_has_checksum_response();
  inline void clear_has_checksum_response();
  inline void set_has_instruct_response();
  inline void clear_has_instruct_response();
  
  ::std::string* error_message_;
  ::aggregator::TransID* trxid_response_;
  ::aggregator::LogonResponse* logon_response_;
  ::aggregator::KeepAliveResponse* keepalive_response_;
  ::aggregator::LogResponse* log_response_;
  ::aggregator::ConfigResponse* config_response_;
  ::aggregator::CollectorFileResponse* collectorfile_response_;
  ::aggregator::CollectRuleResponse* collectrule_response_;
  ::aggregator::FileResponse* file_response_;
  ::aggregator::FileDataResponse* filedata_response_;
  ::aggregator::CheckSumResponse* checksum_response_;
  ::aggregator::InstructResponse* instruct_response_;
  ::google::protobuf::uint32 error_code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_aggregator_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_aggregator_2eproto();
  #endif
  friend void protobuf_AssignDesc_aggregator_2eproto();
  friend void protobuf_ShutdownFile_aggregator_2eproto();
  
  void InitAsDefaultInstance();
  static AggregatorResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// FileID

// required uint32 id = 1;
inline bool FileID::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileID::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileID::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileID::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 FileID::id() const {
  return id_;
}
inline void FileID::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// CheckSumRequest

// required .aggregator.FileID id = 1;
inline bool CheckSumRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckSumRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckSumRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckSumRequest::clear_id() {
  if (id_ != NULL) id_->::aggregator::FileID::Clear();
  clear_has_id();
}
inline const ::aggregator::FileID& CheckSumRequest::id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
inline ::aggregator::FileID* CheckSumRequest::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::aggregator::FileID;
  return id_;
}
inline ::aggregator::FileID* CheckSumRequest::release_id() {
  clear_has_id();
  ::aggregator::FileID* temp = id_;
  id_ = NULL;
  return temp;
}

// required uint32 fb_cs_pos = 2;
inline bool CheckSumRequest::has_fb_cs_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckSumRequest::set_has_fb_cs_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckSumRequest::clear_has_fb_cs_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckSumRequest::clear_fb_cs_pos() {
  fb_cs_pos_ = 0u;
  clear_has_fb_cs_pos();
}
inline ::google::protobuf::uint32 CheckSumRequest::fb_cs_pos() const {
  return fb_cs_pos_;
}
inline void CheckSumRequest::set_fb_cs_pos(::google::protobuf::uint32 value) {
  set_has_fb_cs_pos();
  fb_cs_pos_ = value;
}

// required uint32 fb_cs_count = 3;
inline bool CheckSumRequest::has_fb_cs_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckSumRequest::set_has_fb_cs_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckSumRequest::clear_has_fb_cs_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckSumRequest::clear_fb_cs_count() {
  fb_cs_count_ = 0u;
  clear_has_fb_cs_count();
}
inline ::google::protobuf::uint32 CheckSumRequest::fb_cs_count() const {
  return fb_cs_count_;
}
inline void CheckSumRequest::set_fb_cs_count(::google::protobuf::uint32 value) {
  set_has_fb_cs_count();
  fb_cs_count_ = value;
}

// -------------------------------------------------------------------

// CheckSumResponse

// required .aggregator.FileID id = 1;
inline bool CheckSumResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckSumResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckSumResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckSumResponse::clear_id() {
  if (id_ != NULL) id_->::aggregator::FileID::Clear();
  clear_has_id();
}
inline const ::aggregator::FileID& CheckSumResponse::id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
inline ::aggregator::FileID* CheckSumResponse::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::aggregator::FileID;
  return id_;
}
inline ::aggregator::FileID* CheckSumResponse::release_id() {
  clear_has_id();
  ::aggregator::FileID* temp = id_;
  id_ = NULL;
  return temp;
}

// required uint32 fb_cs_pos = 2;
inline bool CheckSumResponse::has_fb_cs_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckSumResponse::set_has_fb_cs_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckSumResponse::clear_has_fb_cs_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckSumResponse::clear_fb_cs_pos() {
  fb_cs_pos_ = 0u;
  clear_has_fb_cs_pos();
}
inline ::google::protobuf::uint32 CheckSumResponse::fb_cs_pos() const {
  return fb_cs_pos_;
}
inline void CheckSumResponse::set_fb_cs_pos(::google::protobuf::uint32 value) {
  set_has_fb_cs_pos();
  fb_cs_pos_ = value;
}

// required uint32 fb_cs_count = 3;
inline bool CheckSumResponse::has_fb_cs_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckSumResponse::set_has_fb_cs_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckSumResponse::clear_has_fb_cs_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckSumResponse::clear_fb_cs_count() {
  fb_cs_count_ = 0u;
  clear_has_fb_cs_count();
}
inline ::google::protobuf::uint32 CheckSumResponse::fb_cs_count() const {
  return fb_cs_count_;
}
inline void CheckSumResponse::set_fb_cs_count(::google::protobuf::uint32 value) {
  set_has_fb_cs_count();
  fb_cs_count_ = value;
}

// optional bytes fb_cs_data = 4;
inline bool CheckSumResponse::has_fb_cs_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckSumResponse::set_has_fb_cs_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckSumResponse::clear_has_fb_cs_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckSumResponse::clear_fb_cs_data() {
  if (fb_cs_data_ != &::google::protobuf::internal::kEmptyString) {
    fb_cs_data_->clear();
  }
  clear_has_fb_cs_data();
}
inline const ::std::string& CheckSumResponse::fb_cs_data() const {
  return *fb_cs_data_;
}
inline void CheckSumResponse::set_fb_cs_data(const ::std::string& value) {
  set_has_fb_cs_data();
  if (fb_cs_data_ == &::google::protobuf::internal::kEmptyString) {
    fb_cs_data_ = new ::std::string;
  }
  fb_cs_data_->assign(value);
}
inline void CheckSumResponse::set_fb_cs_data(const char* value) {
  set_has_fb_cs_data();
  if (fb_cs_data_ == &::google::protobuf::internal::kEmptyString) {
    fb_cs_data_ = new ::std::string;
  }
  fb_cs_data_->assign(value);
}
inline void CheckSumResponse::set_fb_cs_data(const void* value, size_t size) {
  set_has_fb_cs_data();
  if (fb_cs_data_ == &::google::protobuf::internal::kEmptyString) {
    fb_cs_data_ = new ::std::string;
  }
  fb_cs_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckSumResponse::mutable_fb_cs_data() {
  set_has_fb_cs_data();
  if (fb_cs_data_ == &::google::protobuf::internal::kEmptyString) {
    fb_cs_data_ = new ::std::string;
  }
  return fb_cs_data_;
}
inline ::std::string* CheckSumResponse::release_fb_cs_data() {
  clear_has_fb_cs_data();
  if (fb_cs_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fb_cs_data_;
    fb_cs_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LogRequest

// required uint32 type = 1;
inline bool LogRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 LogRequest::type() const {
  return type_;
}
inline void LogRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required string data = 2;
inline bool LogRequest::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogRequest::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogRequest::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& LogRequest::data() const {
  return *data_;
}
inline void LogRequest::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void LogRequest::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void LogRequest::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogRequest::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* LogRequest::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes content = 3;
inline bool LogRequest::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogRequest::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogRequest::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogRequest::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& LogRequest::content() const {
  return *content_;
}
inline void LogRequest::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void LogRequest::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void LogRequest::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogRequest::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* LogRequest::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LogResponse

// -------------------------------------------------------------------

// FileRequest_File

// required string dir = 1;
inline bool FileRequest_File::has_dir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileRequest_File::set_has_dir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileRequest_File::clear_has_dir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileRequest_File::clear_dir() {
  if (dir_ != &::google::protobuf::internal::kEmptyString) {
    dir_->clear();
  }
  clear_has_dir();
}
inline const ::std::string& FileRequest_File::dir() const {
  return *dir_;
}
inline void FileRequest_File::set_dir(const ::std::string& value) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(value);
}
inline void FileRequest_File::set_dir(const char* value) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(value);
}
inline void FileRequest_File::set_dir(const char* value, size_t size) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileRequest_File::mutable_dir() {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  return dir_;
}
inline ::std::string* FileRequest_File::release_dir() {
  clear_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dir_;
    dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool FileRequest_File::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileRequest_File::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileRequest_File::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileRequest_File::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FileRequest_File::name() const {
  return *name_;
}
inline void FileRequest_File::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FileRequest_File::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FileRequest_File::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileRequest_File::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FileRequest_File::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 ctime = 3;
inline bool FileRequest_File::has_ctime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileRequest_File::set_has_ctime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileRequest_File::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileRequest_File::clear_ctime() {
  ctime_ = GOOGLE_ULONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::uint64 FileRequest_File::ctime() const {
  return ctime_;
}
inline void FileRequest_File::set_ctime(::google::protobuf::uint64 value) {
  set_has_ctime();
  ctime_ = value;
}

// -------------------------------------------------------------------

// FileRequest

// repeated group File = 1 {
inline int FileRequest::file_size() const {
  return file_.size();
}
inline void FileRequest::clear_file() {
  file_.Clear();
}
inline const ::aggregator::FileRequest_File& FileRequest::file(int index) const {
  return file_.Get(index);
}
inline ::aggregator::FileRequest_File* FileRequest::mutable_file(int index) {
  return file_.Mutable(index);
}
inline ::aggregator::FileRequest_File* FileRequest::add_file() {
  return file_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aggregator::FileRequest_File >&
FileRequest::file() const {
  return file_;
}
inline ::google::protobuf::RepeatedPtrField< ::aggregator::FileRequest_File >*
FileRequest::mutable_file() {
  return &file_;
}

// -------------------------------------------------------------------

// FileResponse_File

// required .aggregator.FileID id = 1;
inline bool FileResponse_File::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileResponse_File::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileResponse_File::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileResponse_File::clear_id() {
  if (id_ != NULL) id_->::aggregator::FileID::Clear();
  clear_has_id();
}
inline const ::aggregator::FileID& FileResponse_File::id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
inline ::aggregator::FileID* FileResponse_File::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::aggregator::FileID;
  return id_;
}
inline ::aggregator::FileID* FileResponse_File::release_id() {
  clear_has_id();
  ::aggregator::FileID* temp = id_;
  id_ = NULL;
  return temp;
}

// required string dir = 2;
inline bool FileResponse_File::has_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileResponse_File::set_has_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileResponse_File::clear_has_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileResponse_File::clear_dir() {
  if (dir_ != &::google::protobuf::internal::kEmptyString) {
    dir_->clear();
  }
  clear_has_dir();
}
inline const ::std::string& FileResponse_File::dir() const {
  return *dir_;
}
inline void FileResponse_File::set_dir(const ::std::string& value) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(value);
}
inline void FileResponse_File::set_dir(const char* value) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(value);
}
inline void FileResponse_File::set_dir(const char* value, size_t size) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileResponse_File::mutable_dir() {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  return dir_;
}
inline ::std::string* FileResponse_File::release_dir() {
  clear_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dir_;
    dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 3;
inline bool FileResponse_File::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileResponse_File::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileResponse_File::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileResponse_File::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FileResponse_File::name() const {
  return *name_;
}
inline void FileResponse_File::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FileResponse_File::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FileResponse_File::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileResponse_File::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FileResponse_File::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FileResponse

// repeated group File = 1 {
inline int FileResponse::file_size() const {
  return file_.size();
}
inline void FileResponse::clear_file() {
  file_.Clear();
}
inline const ::aggregator::FileResponse_File& FileResponse::file(int index) const {
  return file_.Get(index);
}
inline ::aggregator::FileResponse_File* FileResponse::mutable_file(int index) {
  return file_.Mutable(index);
}
inline ::aggregator::FileResponse_File* FileResponse::add_file() {
  return file_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aggregator::FileResponse_File >&
FileResponse::file() const {
  return file_;
}
inline ::google::protobuf::RepeatedPtrField< ::aggregator::FileResponse_File >*
FileResponse::mutable_file() {
  return &file_;
}

// -------------------------------------------------------------------

// FileDataRequest_FileData

// required .aggregator.FileID id = 1;
inline bool FileDataRequest_FileData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileDataRequest_FileData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileDataRequest_FileData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileDataRequest_FileData::clear_id() {
  if (id_ != NULL) id_->::aggregator::FileID::Clear();
  clear_has_id();
}
inline const ::aggregator::FileID& FileDataRequest_FileData::id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
inline ::aggregator::FileID* FileDataRequest_FileData::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::aggregator::FileID;
  return id_;
}
inline ::aggregator::FileID* FileDataRequest_FileData::release_id() {
  clear_has_id();
  ::aggregator::FileID* temp = id_;
  id_ = NULL;
  return temp;
}

// required uint64 pos = 2;
inline bool FileDataRequest_FileData::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileDataRequest_FileData::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileDataRequest_FileData::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileDataRequest_FileData::clear_pos() {
  pos_ = GOOGLE_ULONGLONG(0);
  clear_has_pos();
}
inline ::google::protobuf::uint64 FileDataRequest_FileData::pos() const {
  return pos_;
}
inline void FileDataRequest_FileData::set_pos(::google::protobuf::uint64 value) {
  set_has_pos();
  pos_ = value;
}

// required .aggregator.FileDataRequest.FileData.EncodeType encode = 3 [default = NONE];
inline bool FileDataRequest_FileData::has_encode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileDataRequest_FileData::set_has_encode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileDataRequest_FileData::clear_has_encode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileDataRequest_FileData::clear_encode() {
  encode_ = 0;
  clear_has_encode();
}
inline ::aggregator::FileDataRequest_FileData_EncodeType FileDataRequest_FileData::encode() const {
  return static_cast< ::aggregator::FileDataRequest_FileData_EncodeType >(encode_);
}
inline void FileDataRequest_FileData::set_encode(::aggregator::FileDataRequest_FileData_EncodeType value) {
  GOOGLE_DCHECK(::aggregator::FileDataRequest_FileData_EncodeType_IsValid(value));
  set_has_encode();
  encode_ = value;
}

// optional uint32 org_len = 4;
inline bool FileDataRequest_FileData::has_org_len() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileDataRequest_FileData::set_has_org_len() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileDataRequest_FileData::clear_has_org_len() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileDataRequest_FileData::clear_org_len() {
  org_len_ = 0u;
  clear_has_org_len();
}
inline ::google::protobuf::uint32 FileDataRequest_FileData::org_len() const {
  return org_len_;
}
inline void FileDataRequest_FileData::set_org_len(::google::protobuf::uint32 value) {
  set_has_org_len();
  org_len_ = value;
}

// required bytes data = 6;
inline bool FileDataRequest_FileData::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileDataRequest_FileData::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileDataRequest_FileData::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileDataRequest_FileData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& FileDataRequest_FileData::data() const {
  return *data_;
}
inline void FileDataRequest_FileData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void FileDataRequest_FileData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void FileDataRequest_FileData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileDataRequest_FileData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* FileDataRequest_FileData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FileDataRequest

// repeated group FileData = 1 {
inline int FileDataRequest::filedata_size() const {
  return filedata_.size();
}
inline void FileDataRequest::clear_filedata() {
  filedata_.Clear();
}
inline const ::aggregator::FileDataRequest_FileData& FileDataRequest::filedata(int index) const {
  return filedata_.Get(index);
}
inline ::aggregator::FileDataRequest_FileData* FileDataRequest::mutable_filedata(int index) {
  return filedata_.Mutable(index);
}
inline ::aggregator::FileDataRequest_FileData* FileDataRequest::add_filedata() {
  return filedata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aggregator::FileDataRequest_FileData >&
FileDataRequest::filedata() const {
  return filedata_;
}
inline ::google::protobuf::RepeatedPtrField< ::aggregator::FileDataRequest_FileData >*
FileDataRequest::mutable_filedata() {
  return &filedata_;
}

// -------------------------------------------------------------------

// FileDataResponse_FileData

// required .aggregator.FileID id = 1;
inline bool FileDataResponse_FileData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileDataResponse_FileData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileDataResponse_FileData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileDataResponse_FileData::clear_id() {
  if (id_ != NULL) id_->::aggregator::FileID::Clear();
  clear_has_id();
}
inline const ::aggregator::FileID& FileDataResponse_FileData::id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
inline ::aggregator::FileID* FileDataResponse_FileData::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::aggregator::FileID;
  return id_;
}
inline ::aggregator::FileID* FileDataResponse_FileData::release_id() {
  clear_has_id();
  ::aggregator::FileID* temp = id_;
  id_ = NULL;
  return temp;
}

// required uint64 size = 2;
inline bool FileDataResponse_FileData::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileDataResponse_FileData::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileDataResponse_FileData::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileDataResponse_FileData::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 FileDataResponse_FileData::size() const {
  return size_;
}
inline void FileDataResponse_FileData::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// optional .aggregator.FileDataResponse.FileData.FileStatus status = 3;
inline bool FileDataResponse_FileData::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileDataResponse_FileData::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileDataResponse_FileData::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileDataResponse_FileData::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::aggregator::FileDataResponse_FileData_FileStatus FileDataResponse_FileData::status() const {
  return static_cast< ::aggregator::FileDataResponse_FileData_FileStatus >(status_);
}
inline void FileDataResponse_FileData::set_status(::aggregator::FileDataResponse_FileData_FileStatus value) {
  GOOGLE_DCHECK(::aggregator::FileDataResponse_FileData_FileStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional string checksum = 4;
inline bool FileDataResponse_FileData::has_checksum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileDataResponse_FileData::set_has_checksum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileDataResponse_FileData::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileDataResponse_FileData::clear_checksum() {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    checksum_->clear();
  }
  clear_has_checksum();
}
inline const ::std::string& FileDataResponse_FileData::checksum() const {
  return *checksum_;
}
inline void FileDataResponse_FileData::set_checksum(const ::std::string& value) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void FileDataResponse_FileData::set_checksum(const char* value) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void FileDataResponse_FileData::set_checksum(const char* value, size_t size) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileDataResponse_FileData::mutable_checksum() {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  return checksum_;
}
inline ::std::string* FileDataResponse_FileData::release_checksum() {
  clear_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = checksum_;
    checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FileDataResponse

// repeated group FileData = 1 {
inline int FileDataResponse::filedata_size() const {
  return filedata_.size();
}
inline void FileDataResponse::clear_filedata() {
  filedata_.Clear();
}
inline const ::aggregator::FileDataResponse_FileData& FileDataResponse::filedata(int index) const {
  return filedata_.Get(index);
}
inline ::aggregator::FileDataResponse_FileData* FileDataResponse::mutable_filedata(int index) {
  return filedata_.Mutable(index);
}
inline ::aggregator::FileDataResponse_FileData* FileDataResponse::add_filedata() {
  return filedata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aggregator::FileDataResponse_FileData >&
FileDataResponse::filedata() const {
  return filedata_;
}
inline ::google::protobuf::RepeatedPtrField< ::aggregator::FileDataResponse_FileData >*
FileDataResponse::mutable_filedata() {
  return &filedata_;
}

// -------------------------------------------------------------------

// CollectorFileRequest

// -------------------------------------------------------------------

// CollectorFileResponse_File

// required .aggregator.FileID id = 1;
inline bool CollectorFileResponse_File::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollectorFileResponse_File::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollectorFileResponse_File::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollectorFileResponse_File::clear_id() {
  if (id_ != NULL) id_->::aggregator::FileID::Clear();
  clear_has_id();
}
inline const ::aggregator::FileID& CollectorFileResponse_File::id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
inline ::aggregator::FileID* CollectorFileResponse_File::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::aggregator::FileID;
  return id_;
}
inline ::aggregator::FileID* CollectorFileResponse_File::release_id() {
  clear_has_id();
  ::aggregator::FileID* temp = id_;
  id_ = NULL;
  return temp;
}

// required uint64 pos = 2;
inline bool CollectorFileResponse_File::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollectorFileResponse_File::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollectorFileResponse_File::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollectorFileResponse_File::clear_pos() {
  pos_ = GOOGLE_ULONGLONG(0);
  clear_has_pos();
}
inline ::google::protobuf::uint64 CollectorFileResponse_File::pos() const {
  return pos_;
}
inline void CollectorFileResponse_File::set_pos(::google::protobuf::uint64 value) {
  set_has_pos();
  pos_ = value;
}

// required bool finish = 3;
inline bool CollectorFileResponse_File::has_finish() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollectorFileResponse_File::set_has_finish() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollectorFileResponse_File::clear_has_finish() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollectorFileResponse_File::clear_finish() {
  finish_ = false;
  clear_has_finish();
}
inline bool CollectorFileResponse_File::finish() const {
  return finish_;
}
inline void CollectorFileResponse_File::set_finish(bool value) {
  set_has_finish();
  finish_ = value;
}

// required string dir = 4;
inline bool CollectorFileResponse_File::has_dir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CollectorFileResponse_File::set_has_dir() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CollectorFileResponse_File::clear_has_dir() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CollectorFileResponse_File::clear_dir() {
  if (dir_ != &::google::protobuf::internal::kEmptyString) {
    dir_->clear();
  }
  clear_has_dir();
}
inline const ::std::string& CollectorFileResponse_File::dir() const {
  return *dir_;
}
inline void CollectorFileResponse_File::set_dir(const ::std::string& value) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(value);
}
inline void CollectorFileResponse_File::set_dir(const char* value) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(value);
}
inline void CollectorFileResponse_File::set_dir(const char* value, size_t size) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectorFileResponse_File::mutable_dir() {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  return dir_;
}
inline ::std::string* CollectorFileResponse_File::release_dir() {
  clear_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dir_;
    dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 5;
inline bool CollectorFileResponse_File::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CollectorFileResponse_File::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CollectorFileResponse_File::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CollectorFileResponse_File::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CollectorFileResponse_File::name() const {
  return *name_;
}
inline void CollectorFileResponse_File::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CollectorFileResponse_File::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CollectorFileResponse_File::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectorFileResponse_File::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CollectorFileResponse_File::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CollectorFileResponse

// repeated group File = 1 {
inline int CollectorFileResponse::file_size() const {
  return file_.size();
}
inline void CollectorFileResponse::clear_file() {
  file_.Clear();
}
inline const ::aggregator::CollectorFileResponse_File& CollectorFileResponse::file(int index) const {
  return file_.Get(index);
}
inline ::aggregator::CollectorFileResponse_File* CollectorFileResponse::mutable_file(int index) {
  return file_.Mutable(index);
}
inline ::aggregator::CollectorFileResponse_File* CollectorFileResponse::add_file() {
  return file_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aggregator::CollectorFileResponse_File >&
CollectorFileResponse::file() const {
  return file_;
}
inline ::google::protobuf::RepeatedPtrField< ::aggregator::CollectorFileResponse_File >*
CollectorFileResponse::mutable_file() {
  return &file_;
}

// -------------------------------------------------------------------

// CollectRuleRequest

// -------------------------------------------------------------------

// CollectRuleResponse_Rule

// required string dir = 1;
inline bool CollectRuleResponse_Rule::has_dir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollectRuleResponse_Rule::set_has_dir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollectRuleResponse_Rule::clear_has_dir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollectRuleResponse_Rule::clear_dir() {
  if (dir_ != &::google::protobuf::internal::kEmptyString) {
    dir_->clear();
  }
  clear_has_dir();
}
inline const ::std::string& CollectRuleResponse_Rule::dir() const {
  return *dir_;
}
inline void CollectRuleResponse_Rule::set_dir(const ::std::string& value) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(value);
}
inline void CollectRuleResponse_Rule::set_dir(const char* value) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(value);
}
inline void CollectRuleResponse_Rule::set_dir(const char* value, size_t size) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectRuleResponse_Rule::mutable_dir() {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    dir_ = new ::std::string;
  }
  return dir_;
}
inline ::std::string* CollectRuleResponse_Rule::release_dir() {
  clear_has_dir();
  if (dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dir_;
    dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string exclude = 2;
inline bool CollectRuleResponse_Rule::has_exclude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollectRuleResponse_Rule::set_has_exclude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollectRuleResponse_Rule::clear_has_exclude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollectRuleResponse_Rule::clear_exclude() {
  if (exclude_ != &::google::protobuf::internal::kEmptyString) {
    exclude_->clear();
  }
  clear_has_exclude();
}
inline const ::std::string& CollectRuleResponse_Rule::exclude() const {
  return *exclude_;
}
inline void CollectRuleResponse_Rule::set_exclude(const ::std::string& value) {
  set_has_exclude();
  if (exclude_ == &::google::protobuf::internal::kEmptyString) {
    exclude_ = new ::std::string;
  }
  exclude_->assign(value);
}
inline void CollectRuleResponse_Rule::set_exclude(const char* value) {
  set_has_exclude();
  if (exclude_ == &::google::protobuf::internal::kEmptyString) {
    exclude_ = new ::std::string;
  }
  exclude_->assign(value);
}
inline void CollectRuleResponse_Rule::set_exclude(const char* value, size_t size) {
  set_has_exclude();
  if (exclude_ == &::google::protobuf::internal::kEmptyString) {
    exclude_ = new ::std::string;
  }
  exclude_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectRuleResponse_Rule::mutable_exclude() {
  set_has_exclude();
  if (exclude_ == &::google::protobuf::internal::kEmptyString) {
    exclude_ = new ::std::string;
  }
  return exclude_;
}
inline ::std::string* CollectRuleResponse_Rule::release_exclude() {
  clear_has_exclude();
  if (exclude_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exclude_;
    exclude_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string include = 3;
inline bool CollectRuleResponse_Rule::has_include() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollectRuleResponse_Rule::set_has_include() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollectRuleResponse_Rule::clear_has_include() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollectRuleResponse_Rule::clear_include() {
  if (include_ != &::google::protobuf::internal::kEmptyString) {
    include_->clear();
  }
  clear_has_include();
}
inline const ::std::string& CollectRuleResponse_Rule::include() const {
  return *include_;
}
inline void CollectRuleResponse_Rule::set_include(const ::std::string& value) {
  set_has_include();
  if (include_ == &::google::protobuf::internal::kEmptyString) {
    include_ = new ::std::string;
  }
  include_->assign(value);
}
inline void CollectRuleResponse_Rule::set_include(const char* value) {
  set_has_include();
  if (include_ == &::google::protobuf::internal::kEmptyString) {
    include_ = new ::std::string;
  }
  include_->assign(value);
}
inline void CollectRuleResponse_Rule::set_include(const char* value, size_t size) {
  set_has_include();
  if (include_ == &::google::protobuf::internal::kEmptyString) {
    include_ = new ::std::string;
  }
  include_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectRuleResponse_Rule::mutable_include() {
  set_has_include();
  if (include_ == &::google::protobuf::internal::kEmptyString) {
    include_ = new ::std::string;
  }
  return include_;
}
inline ::std::string* CollectRuleResponse_Rule::release_include() {
  clear_has_include();
  if (include_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = include_;
    include_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CollectRuleResponse

// repeated group Rule = 1 {
inline int CollectRuleResponse::rule_size() const {
  return rule_.size();
}
inline void CollectRuleResponse::clear_rule() {
  rule_.Clear();
}
inline const ::aggregator::CollectRuleResponse_Rule& CollectRuleResponse::rule(int index) const {
  return rule_.Get(index);
}
inline ::aggregator::CollectRuleResponse_Rule* CollectRuleResponse::mutable_rule(int index) {
  return rule_.Mutable(index);
}
inline ::aggregator::CollectRuleResponse_Rule* CollectRuleResponse::add_rule() {
  return rule_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aggregator::CollectRuleResponse_Rule >&
CollectRuleResponse::rule() const {
  return rule_;
}
inline ::google::protobuf::RepeatedPtrField< ::aggregator::CollectRuleResponse_Rule >*
CollectRuleResponse::mutable_rule() {
  return &rule_;
}

// -------------------------------------------------------------------

// ConfigRequest

// -------------------------------------------------------------------

// ConfigResponse_Time

// required uint32 no = 1;
inline bool ConfigResponse_Time::has_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigResponse_Time::set_has_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigResponse_Time::clear_has_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigResponse_Time::clear_no() {
  no_ = 0u;
  clear_has_no();
}
inline ::google::protobuf::uint32 ConfigResponse_Time::no() const {
  return no_;
}
inline void ConfigResponse_Time::set_no(::google::protobuf::uint32 value) {
  set_has_no();
  no_ = value;
}

// required uint32 keepalive = 2;
inline bool ConfigResponse_Time::has_keepalive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigResponse_Time::set_has_keepalive() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigResponse_Time::clear_has_keepalive() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigResponse_Time::clear_keepalive() {
  keepalive_ = 0u;
  clear_has_keepalive();
}
inline ::google::protobuf::uint32 ConfigResponse_Time::keepalive() const {
  return keepalive_;
}
inline void ConfigResponse_Time::set_keepalive(::google::protobuf::uint32 value) {
  set_has_keepalive();
  keepalive_ = value;
}

// required uint32 rate = 3;
inline bool ConfigResponse_Time::has_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfigResponse_Time::set_has_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfigResponse_Time::clear_has_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfigResponse_Time::clear_rate() {
  rate_ = 0u;
  clear_has_rate();
}
inline ::google::protobuf::uint32 ConfigResponse_Time::rate() const {
  return rate_;
}
inline void ConfigResponse_Time::set_rate(::google::protobuf::uint32 value) {
  set_has_rate();
  rate_ = value;
}

// required uint32 start = 4;
inline bool ConfigResponse_Time::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConfigResponse_Time::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConfigResponse_Time::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConfigResponse_Time::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 ConfigResponse_Time::start() const {
  return start_;
}
inline void ConfigResponse_Time::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// required uint32 end = 5;
inline bool ConfigResponse_Time::has_end() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConfigResponse_Time::set_has_end() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConfigResponse_Time::clear_has_end() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConfigResponse_Time::clear_end() {
  end_ = 0u;
  clear_has_end();
}
inline ::google::protobuf::uint32 ConfigResponse_Time::end() const {
  return end_;
}
inline void ConfigResponse_Time::set_end(::google::protobuf::uint32 value) {
  set_has_end();
  end_ = value;
}

// required uint32 steptime = 6;
inline bool ConfigResponse_Time::has_steptime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConfigResponse_Time::set_has_steptime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConfigResponse_Time::clear_has_steptime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConfigResponse_Time::clear_steptime() {
  steptime_ = 0u;
  clear_has_steptime();
}
inline ::google::protobuf::uint32 ConfigResponse_Time::steptime() const {
  return steptime_;
}
inline void ConfigResponse_Time::set_steptime(::google::protobuf::uint32 value) {
  set_has_steptime();
  steptime_ = value;
}

// -------------------------------------------------------------------

// ConfigResponse

// repeated group Time = 1 {
inline int ConfigResponse::time_size() const {
  return time_.size();
}
inline void ConfigResponse::clear_time() {
  time_.Clear();
}
inline const ::aggregator::ConfigResponse_Time& ConfigResponse::time(int index) const {
  return time_.Get(index);
}
inline ::aggregator::ConfigResponse_Time* ConfigResponse::mutable_time(int index) {
  return time_.Mutable(index);
}
inline ::aggregator::ConfigResponse_Time* ConfigResponse::add_time() {
  return time_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aggregator::ConfigResponse_Time >&
ConfigResponse::time() const {
  return time_;
}
inline ::google::protobuf::RepeatedPtrField< ::aggregator::ConfigResponse_Time >*
ConfigResponse::mutable_time() {
  return &time_;
}

// -------------------------------------------------------------------

// LogonRequest

// required uint32 ver = 1;
inline bool LogonRequest::has_ver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogonRequest::set_has_ver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogonRequest::clear_has_ver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogonRequest::clear_ver() {
  ver_ = 0u;
  clear_has_ver();
}
inline ::google::protobuf::uint32 LogonRequest::ver() const {
  return ver_;
}
inline void LogonRequest::set_ver(::google::protobuf::uint32 value) {
  set_has_ver();
  ver_ = value;
}

// required string name = 2;
inline bool LogonRequest::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogonRequest::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogonRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogonRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LogonRequest::name() const {
  return *name_;
}
inline void LogonRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LogonRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LogonRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogonRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LogonRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes info = 3;
inline bool LogonRequest::has_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogonRequest::set_has_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogonRequest::clear_has_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogonRequest::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& LogonRequest::info() const {
  return *info_;
}
inline void LogonRequest::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void LogonRequest::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void LogonRequest::set_info(const void* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogonRequest::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* LogonRequest::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LogonResponse

// required uint64 session_id = 1;
inline bool LogonResponse::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogonResponse::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogonResponse::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogonResponse::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 LogonResponse::session_id() const {
  return session_id_;
}
inline void LogonResponse::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional bytes info = 2;
inline bool LogonResponse::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogonResponse::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogonResponse::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogonResponse::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& LogonResponse::info() const {
  return *info_;
}
inline void LogonResponse::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void LogonResponse::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void LogonResponse::set_info(const void* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogonResponse::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* LogonResponse::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LogoutRequest

// optional string msg = 1;
inline bool LogoutRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutRequest::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& LogoutRequest::msg() const {
  return *msg_;
}
inline void LogoutRequest::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void LogoutRequest::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void LogoutRequest::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogoutRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* LogoutRequest::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// KeepAliveRequest

// required uint64 sync_pos = 1;
inline bool KeepAliveRequest::has_sync_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeepAliveRequest::set_has_sync_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeepAliveRequest::clear_has_sync_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeepAliveRequest::clear_sync_pos() {
  sync_pos_ = GOOGLE_ULONGLONG(0);
  clear_has_sync_pos();
}
inline ::google::protobuf::uint64 KeepAliveRequest::sync_pos() const {
  return sync_pos_;
}
inline void KeepAliveRequest::set_sync_pos(::google::protobuf::uint64 value) {
  set_has_sync_pos();
  sync_pos_ = value;
}

// optional string msg = 2;
inline bool KeepAliveRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeepAliveRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeepAliveRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeepAliveRequest::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& KeepAliveRequest::msg() const {
  return *msg_;
}
inline void KeepAliveRequest::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void KeepAliveRequest::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void KeepAliveRequest::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeepAliveRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* KeepAliveRequest::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// KeepAliveResponse

// required uint64 sync_pos = 1;
inline bool KeepAliveResponse::has_sync_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeepAliveResponse::set_has_sync_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeepAliveResponse::clear_has_sync_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeepAliveResponse::clear_sync_pos() {
  sync_pos_ = GOOGLE_ULONGLONG(0);
  clear_has_sync_pos();
}
inline ::google::protobuf::uint64 KeepAliveResponse::sync_pos() const {
  return sync_pos_;
}
inline void KeepAliveResponse::set_sync_pos(::google::protobuf::uint64 value) {
  set_has_sync_pos();
  sync_pos_ = value;
}

// optional string msg = 2;
inline bool KeepAliveResponse::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeepAliveResponse::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeepAliveResponse::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeepAliveResponse::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& KeepAliveResponse::msg() const {
  return *msg_;
}
inline void KeepAliveResponse::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void KeepAliveResponse::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void KeepAliveResponse::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeepAliveResponse::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* KeepAliveResponse::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InstructResponse

// required uint32 instruction = 1;
inline bool InstructResponse::has_instruction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstructResponse::set_has_instruction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstructResponse::clear_has_instruction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstructResponse::clear_instruction() {
  instruction_ = 0u;
  clear_has_instruction();
}
inline ::google::protobuf::uint32 InstructResponse::instruction() const {
  return instruction_;
}
inline void InstructResponse::set_instruction(::google::protobuf::uint32 value) {
  set_has_instruction();
  instruction_ = value;
}

// -------------------------------------------------------------------

// TransID

// required uint32 id = 1;
inline bool TransID::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransID::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransID::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransID::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TransID::id() const {
  return id_;
}
inline void TransID::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// CollectorRequest

// required uint64 session_id = 1;
inline bool CollectorRequest::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollectorRequest::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollectorRequest::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollectorRequest::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 CollectorRequest::session_id() const {
  return session_id_;
}
inline void CollectorRequest::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional .aggregator.TransID trxid_request = 3;
inline bool CollectorRequest::has_trxid_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollectorRequest::set_has_trxid_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollectorRequest::clear_has_trxid_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollectorRequest::clear_trxid_request() {
  if (trxid_request_ != NULL) trxid_request_->::aggregator::TransID::Clear();
  clear_has_trxid_request();
}
inline const ::aggregator::TransID& CollectorRequest::trxid_request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trxid_request_ != NULL ? *trxid_request_ : *default_instance().trxid_request_;
#else
  return trxid_request_ != NULL ? *trxid_request_ : *default_instance_->trxid_request_;
#endif
}
inline ::aggregator::TransID* CollectorRequest::mutable_trxid_request() {
  set_has_trxid_request();
  if (trxid_request_ == NULL) trxid_request_ = new ::aggregator::TransID;
  return trxid_request_;
}
inline ::aggregator::TransID* CollectorRequest::release_trxid_request() {
  clear_has_trxid_request();
  ::aggregator::TransID* temp = trxid_request_;
  trxid_request_ = NULL;
  return temp;
}

// optional .aggregator.LogonRequest logon_request = 5;
inline bool CollectorRequest::has_logon_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollectorRequest::set_has_logon_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollectorRequest::clear_has_logon_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollectorRequest::clear_logon_request() {
  if (logon_request_ != NULL) logon_request_->::aggregator::LogonRequest::Clear();
  clear_has_logon_request();
}
inline const ::aggregator::LogonRequest& CollectorRequest::logon_request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return logon_request_ != NULL ? *logon_request_ : *default_instance().logon_request_;
#else
  return logon_request_ != NULL ? *logon_request_ : *default_instance_->logon_request_;
#endif
}
inline ::aggregator::LogonRequest* CollectorRequest::mutable_logon_request() {
  set_has_logon_request();
  if (logon_request_ == NULL) logon_request_ = new ::aggregator::LogonRequest;
  return logon_request_;
}
inline ::aggregator::LogonRequest* CollectorRequest::release_logon_request() {
  clear_has_logon_request();
  ::aggregator::LogonRequest* temp = logon_request_;
  logon_request_ = NULL;
  return temp;
}

// optional .aggregator.LogoutRequest logout_request = 6;
inline bool CollectorRequest::has_logout_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CollectorRequest::set_has_logout_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CollectorRequest::clear_has_logout_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CollectorRequest::clear_logout_request() {
  if (logout_request_ != NULL) logout_request_->::aggregator::LogoutRequest::Clear();
  clear_has_logout_request();
}
inline const ::aggregator::LogoutRequest& CollectorRequest::logout_request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return logout_request_ != NULL ? *logout_request_ : *default_instance().logout_request_;
#else
  return logout_request_ != NULL ? *logout_request_ : *default_instance_->logout_request_;
#endif
}
inline ::aggregator::LogoutRequest* CollectorRequest::mutable_logout_request() {
  set_has_logout_request();
  if (logout_request_ == NULL) logout_request_ = new ::aggregator::LogoutRequest;
  return logout_request_;
}
inline ::aggregator::LogoutRequest* CollectorRequest::release_logout_request() {
  clear_has_logout_request();
  ::aggregator::LogoutRequest* temp = logout_request_;
  logout_request_ = NULL;
  return temp;
}

// optional .aggregator.KeepAliveRequest keepalive_request = 7;
inline bool CollectorRequest::has_keepalive_request() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CollectorRequest::set_has_keepalive_request() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CollectorRequest::clear_has_keepalive_request() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CollectorRequest::clear_keepalive_request() {
  if (keepalive_request_ != NULL) keepalive_request_->::aggregator::KeepAliveRequest::Clear();
  clear_has_keepalive_request();
}
inline const ::aggregator::KeepAliveRequest& CollectorRequest::keepalive_request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return keepalive_request_ != NULL ? *keepalive_request_ : *default_instance().keepalive_request_;
#else
  return keepalive_request_ != NULL ? *keepalive_request_ : *default_instance_->keepalive_request_;
#endif
}
inline ::aggregator::KeepAliveRequest* CollectorRequest::mutable_keepalive_request() {
  set_has_keepalive_request();
  if (keepalive_request_ == NULL) keepalive_request_ = new ::aggregator::KeepAliveRequest;
  return keepalive_request_;
}
inline ::aggregator::KeepAliveRequest* CollectorRequest::release_keepalive_request() {
  clear_has_keepalive_request();
  ::aggregator::KeepAliveRequest* temp = keepalive_request_;
  keepalive_request_ = NULL;
  return temp;
}

// optional .aggregator.LogRequest log_request = 8;
inline bool CollectorRequest::has_log_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CollectorRequest::set_has_log_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CollectorRequest::clear_has_log_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CollectorRequest::clear_log_request() {
  if (log_request_ != NULL) log_request_->::aggregator::LogRequest::Clear();
  clear_has_log_request();
}
inline const ::aggregator::LogRequest& CollectorRequest::log_request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return log_request_ != NULL ? *log_request_ : *default_instance().log_request_;
#else
  return log_request_ != NULL ? *log_request_ : *default_instance_->log_request_;
#endif
}
inline ::aggregator::LogRequest* CollectorRequest::mutable_log_request() {
  set_has_log_request();
  if (log_request_ == NULL) log_request_ = new ::aggregator::LogRequest;
  return log_request_;
}
inline ::aggregator::LogRequest* CollectorRequest::release_log_request() {
  clear_has_log_request();
  ::aggregator::LogRequest* temp = log_request_;
  log_request_ = NULL;
  return temp;
}

// optional .aggregator.ConfigRequest config_request = 10;
inline bool CollectorRequest::has_config_request() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CollectorRequest::set_has_config_request() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CollectorRequest::clear_has_config_request() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CollectorRequest::clear_config_request() {
  if (config_request_ != NULL) config_request_->::aggregator::ConfigRequest::Clear();
  clear_has_config_request();
}
inline const ::aggregator::ConfigRequest& CollectorRequest::config_request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_request_ != NULL ? *config_request_ : *default_instance().config_request_;
#else
  return config_request_ != NULL ? *config_request_ : *default_instance_->config_request_;
#endif
}
inline ::aggregator::ConfigRequest* CollectorRequest::mutable_config_request() {
  set_has_config_request();
  if (config_request_ == NULL) config_request_ = new ::aggregator::ConfigRequest;
  return config_request_;
}
inline ::aggregator::ConfigRequest* CollectorRequest::release_config_request() {
  clear_has_config_request();
  ::aggregator::ConfigRequest* temp = config_request_;
  config_request_ = NULL;
  return temp;
}

// optional .aggregator.CollectorFileRequest collectorfile_request = 11;
inline bool CollectorRequest::has_collectorfile_request() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CollectorRequest::set_has_collectorfile_request() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CollectorRequest::clear_has_collectorfile_request() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CollectorRequest::clear_collectorfile_request() {
  if (collectorfile_request_ != NULL) collectorfile_request_->::aggregator::CollectorFileRequest::Clear();
  clear_has_collectorfile_request();
}
inline const ::aggregator::CollectorFileRequest& CollectorRequest::collectorfile_request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return collectorfile_request_ != NULL ? *collectorfile_request_ : *default_instance().collectorfile_request_;
#else
  return collectorfile_request_ != NULL ? *collectorfile_request_ : *default_instance_->collectorfile_request_;
#endif
}
inline ::aggregator::CollectorFileRequest* CollectorRequest::mutable_collectorfile_request() {
  set_has_collectorfile_request();
  if (collectorfile_request_ == NULL) collectorfile_request_ = new ::aggregator::CollectorFileRequest;
  return collectorfile_request_;
}
inline ::aggregator::CollectorFileRequest* CollectorRequest::release_collectorfile_request() {
  clear_has_collectorfile_request();
  ::aggregator::CollectorFileRequest* temp = collectorfile_request_;
  collectorfile_request_ = NULL;
  return temp;
}

// optional .aggregator.CollectRuleRequest collectrule_request = 12;
inline bool CollectorRequest::has_collectrule_request() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CollectorRequest::set_has_collectrule_request() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CollectorRequest::clear_has_collectrule_request() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CollectorRequest::clear_collectrule_request() {
  if (collectrule_request_ != NULL) collectrule_request_->::aggregator::CollectRuleRequest::Clear();
  clear_has_collectrule_request();
}
inline const ::aggregator::CollectRuleRequest& CollectorRequest::collectrule_request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return collectrule_request_ != NULL ? *collectrule_request_ : *default_instance().collectrule_request_;
#else
  return collectrule_request_ != NULL ? *collectrule_request_ : *default_instance_->collectrule_request_;
#endif
}
inline ::aggregator::CollectRuleRequest* CollectorRequest::mutable_collectrule_request() {
  set_has_collectrule_request();
  if (collectrule_request_ == NULL) collectrule_request_ = new ::aggregator::CollectRuleRequest;
  return collectrule_request_;
}
inline ::aggregator::CollectRuleRequest* CollectorRequest::release_collectrule_request() {
  clear_has_collectrule_request();
  ::aggregator::CollectRuleRequest* temp = collectrule_request_;
  collectrule_request_ = NULL;
  return temp;
}

// optional .aggregator.FileRequest file_request = 13;
inline bool CollectorRequest::has_file_request() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CollectorRequest::set_has_file_request() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CollectorRequest::clear_has_file_request() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CollectorRequest::clear_file_request() {
  if (file_request_ != NULL) file_request_->::aggregator::FileRequest::Clear();
  clear_has_file_request();
}
inline const ::aggregator::FileRequest& CollectorRequest::file_request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return file_request_ != NULL ? *file_request_ : *default_instance().file_request_;
#else
  return file_request_ != NULL ? *file_request_ : *default_instance_->file_request_;
#endif
}
inline ::aggregator::FileRequest* CollectorRequest::mutable_file_request() {
  set_has_file_request();
  if (file_request_ == NULL) file_request_ = new ::aggregator::FileRequest;
  return file_request_;
}
inline ::aggregator::FileRequest* CollectorRequest::release_file_request() {
  clear_has_file_request();
  ::aggregator::FileRequest* temp = file_request_;
  file_request_ = NULL;
  return temp;
}

// optional .aggregator.FileDataRequest filedata_request = 14;
inline bool CollectorRequest::has_filedata_request() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CollectorRequest::set_has_filedata_request() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CollectorRequest::clear_has_filedata_request() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CollectorRequest::clear_filedata_request() {
  if (filedata_request_ != NULL) filedata_request_->::aggregator::FileDataRequest::Clear();
  clear_has_filedata_request();
}
inline const ::aggregator::FileDataRequest& CollectorRequest::filedata_request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return filedata_request_ != NULL ? *filedata_request_ : *default_instance().filedata_request_;
#else
  return filedata_request_ != NULL ? *filedata_request_ : *default_instance_->filedata_request_;
#endif
}
inline ::aggregator::FileDataRequest* CollectorRequest::mutable_filedata_request() {
  set_has_filedata_request();
  if (filedata_request_ == NULL) filedata_request_ = new ::aggregator::FileDataRequest;
  return filedata_request_;
}
inline ::aggregator::FileDataRequest* CollectorRequest::release_filedata_request() {
  clear_has_filedata_request();
  ::aggregator::FileDataRequest* temp = filedata_request_;
  filedata_request_ = NULL;
  return temp;
}

// optional .aggregator.CheckSumRequest checksum_request = 15;
inline bool CollectorRequest::has_checksum_request() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CollectorRequest::set_has_checksum_request() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CollectorRequest::clear_has_checksum_request() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CollectorRequest::clear_checksum_request() {
  if (checksum_request_ != NULL) checksum_request_->::aggregator::CheckSumRequest::Clear();
  clear_has_checksum_request();
}
inline const ::aggregator::CheckSumRequest& CollectorRequest::checksum_request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return checksum_request_ != NULL ? *checksum_request_ : *default_instance().checksum_request_;
#else
  return checksum_request_ != NULL ? *checksum_request_ : *default_instance_->checksum_request_;
#endif
}
inline ::aggregator::CheckSumRequest* CollectorRequest::mutable_checksum_request() {
  set_has_checksum_request();
  if (checksum_request_ == NULL) checksum_request_ = new ::aggregator::CheckSumRequest;
  return checksum_request_;
}
inline ::aggregator::CheckSumRequest* CollectorRequest::release_checksum_request() {
  clear_has_checksum_request();
  ::aggregator::CheckSumRequest* temp = checksum_request_;
  checksum_request_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// AggregatorResponse

// required uint32 error_code = 1;
inline bool AggregatorResponse::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AggregatorResponse::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AggregatorResponse::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AggregatorResponse::clear_error_code() {
  error_code_ = 0u;
  clear_has_error_code();
}
inline ::google::protobuf::uint32 AggregatorResponse::error_code() const {
  return error_code_;
}
inline void AggregatorResponse::set_error_code(::google::protobuf::uint32 value) {
  set_has_error_code();
  error_code_ = value;
}

// optional string error_message = 2;
inline bool AggregatorResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AggregatorResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AggregatorResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AggregatorResponse::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& AggregatorResponse::error_message() const {
  return *error_message_;
}
inline void AggregatorResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void AggregatorResponse::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void AggregatorResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AggregatorResponse::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}
inline ::std::string* AggregatorResponse::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .aggregator.TransID trxid_response = 3;
inline bool AggregatorResponse::has_trxid_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AggregatorResponse::set_has_trxid_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AggregatorResponse::clear_has_trxid_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AggregatorResponse::clear_trxid_response() {
  if (trxid_response_ != NULL) trxid_response_->::aggregator::TransID::Clear();
  clear_has_trxid_response();
}
inline const ::aggregator::TransID& AggregatorResponse::trxid_response() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trxid_response_ != NULL ? *trxid_response_ : *default_instance().trxid_response_;
#else
  return trxid_response_ != NULL ? *trxid_response_ : *default_instance_->trxid_response_;
#endif
}
inline ::aggregator::TransID* AggregatorResponse::mutable_trxid_response() {
  set_has_trxid_response();
  if (trxid_response_ == NULL) trxid_response_ = new ::aggregator::TransID;
  return trxid_response_;
}
inline ::aggregator::TransID* AggregatorResponse::release_trxid_response() {
  clear_has_trxid_response();
  ::aggregator::TransID* temp = trxid_response_;
  trxid_response_ = NULL;
  return temp;
}

// optional .aggregator.LogonResponse logon_response = 5;
inline bool AggregatorResponse::has_logon_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AggregatorResponse::set_has_logon_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AggregatorResponse::clear_has_logon_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AggregatorResponse::clear_logon_response() {
  if (logon_response_ != NULL) logon_response_->::aggregator::LogonResponse::Clear();
  clear_has_logon_response();
}
inline const ::aggregator::LogonResponse& AggregatorResponse::logon_response() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return logon_response_ != NULL ? *logon_response_ : *default_instance().logon_response_;
#else
  return logon_response_ != NULL ? *logon_response_ : *default_instance_->logon_response_;
#endif
}
inline ::aggregator::LogonResponse* AggregatorResponse::mutable_logon_response() {
  set_has_logon_response();
  if (logon_response_ == NULL) logon_response_ = new ::aggregator::LogonResponse;
  return logon_response_;
}
inline ::aggregator::LogonResponse* AggregatorResponse::release_logon_response() {
  clear_has_logon_response();
  ::aggregator::LogonResponse* temp = logon_response_;
  logon_response_ = NULL;
  return temp;
}

// optional .aggregator.KeepAliveResponse keepalive_response = 7;
inline bool AggregatorResponse::has_keepalive_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AggregatorResponse::set_has_keepalive_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AggregatorResponse::clear_has_keepalive_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AggregatorResponse::clear_keepalive_response() {
  if (keepalive_response_ != NULL) keepalive_response_->::aggregator::KeepAliveResponse::Clear();
  clear_has_keepalive_response();
}
inline const ::aggregator::KeepAliveResponse& AggregatorResponse::keepalive_response() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return keepalive_response_ != NULL ? *keepalive_response_ : *default_instance().keepalive_response_;
#else
  return keepalive_response_ != NULL ? *keepalive_response_ : *default_instance_->keepalive_response_;
#endif
}
inline ::aggregator::KeepAliveResponse* AggregatorResponse::mutable_keepalive_response() {
  set_has_keepalive_response();
  if (keepalive_response_ == NULL) keepalive_response_ = new ::aggregator::KeepAliveResponse;
  return keepalive_response_;
}
inline ::aggregator::KeepAliveResponse* AggregatorResponse::release_keepalive_response() {
  clear_has_keepalive_response();
  ::aggregator::KeepAliveResponse* temp = keepalive_response_;
  keepalive_response_ = NULL;
  return temp;
}

// optional .aggregator.LogResponse log_response = 8;
inline bool AggregatorResponse::has_log_response() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AggregatorResponse::set_has_log_response() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AggregatorResponse::clear_has_log_response() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AggregatorResponse::clear_log_response() {
  if (log_response_ != NULL) log_response_->::aggregator::LogResponse::Clear();
  clear_has_log_response();
}
inline const ::aggregator::LogResponse& AggregatorResponse::log_response() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return log_response_ != NULL ? *log_response_ : *default_instance().log_response_;
#else
  return log_response_ != NULL ? *log_response_ : *default_instance_->log_response_;
#endif
}
inline ::aggregator::LogResponse* AggregatorResponse::mutable_log_response() {
  set_has_log_response();
  if (log_response_ == NULL) log_response_ = new ::aggregator::LogResponse;
  return log_response_;
}
inline ::aggregator::LogResponse* AggregatorResponse::release_log_response() {
  clear_has_log_response();
  ::aggregator::LogResponse* temp = log_response_;
  log_response_ = NULL;
  return temp;
}

// optional .aggregator.ConfigResponse config_response = 10;
inline bool AggregatorResponse::has_config_response() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AggregatorResponse::set_has_config_response() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AggregatorResponse::clear_has_config_response() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AggregatorResponse::clear_config_response() {
  if (config_response_ != NULL) config_response_->::aggregator::ConfigResponse::Clear();
  clear_has_config_response();
}
inline const ::aggregator::ConfigResponse& AggregatorResponse::config_response() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_response_ != NULL ? *config_response_ : *default_instance().config_response_;
#else
  return config_response_ != NULL ? *config_response_ : *default_instance_->config_response_;
#endif
}
inline ::aggregator::ConfigResponse* AggregatorResponse::mutable_config_response() {
  set_has_config_response();
  if (config_response_ == NULL) config_response_ = new ::aggregator::ConfigResponse;
  return config_response_;
}
inline ::aggregator::ConfigResponse* AggregatorResponse::release_config_response() {
  clear_has_config_response();
  ::aggregator::ConfigResponse* temp = config_response_;
  config_response_ = NULL;
  return temp;
}

// optional .aggregator.CollectorFileResponse collectorfile_response = 11;
inline bool AggregatorResponse::has_collectorfile_response() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AggregatorResponse::set_has_collectorfile_response() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AggregatorResponse::clear_has_collectorfile_response() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AggregatorResponse::clear_collectorfile_response() {
  if (collectorfile_response_ != NULL) collectorfile_response_->::aggregator::CollectorFileResponse::Clear();
  clear_has_collectorfile_response();
}
inline const ::aggregator::CollectorFileResponse& AggregatorResponse::collectorfile_response() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return collectorfile_response_ != NULL ? *collectorfile_response_ : *default_instance().collectorfile_response_;
#else
  return collectorfile_response_ != NULL ? *collectorfile_response_ : *default_instance_->collectorfile_response_;
#endif
}
inline ::aggregator::CollectorFileResponse* AggregatorResponse::mutable_collectorfile_response() {
  set_has_collectorfile_response();
  if (collectorfile_response_ == NULL) collectorfile_response_ = new ::aggregator::CollectorFileResponse;
  return collectorfile_response_;
}
inline ::aggregator::CollectorFileResponse* AggregatorResponse::release_collectorfile_response() {
  clear_has_collectorfile_response();
  ::aggregator::CollectorFileResponse* temp = collectorfile_response_;
  collectorfile_response_ = NULL;
  return temp;
}

// optional .aggregator.CollectRuleResponse collectrule_response = 12;
inline bool AggregatorResponse::has_collectrule_response() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AggregatorResponse::set_has_collectrule_response() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AggregatorResponse::clear_has_collectrule_response() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AggregatorResponse::clear_collectrule_response() {
  if (collectrule_response_ != NULL) collectrule_response_->::aggregator::CollectRuleResponse::Clear();
  clear_has_collectrule_response();
}
inline const ::aggregator::CollectRuleResponse& AggregatorResponse::collectrule_response() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return collectrule_response_ != NULL ? *collectrule_response_ : *default_instance().collectrule_response_;
#else
  return collectrule_response_ != NULL ? *collectrule_response_ : *default_instance_->collectrule_response_;
#endif
}
inline ::aggregator::CollectRuleResponse* AggregatorResponse::mutable_collectrule_response() {
  set_has_collectrule_response();
  if (collectrule_response_ == NULL) collectrule_response_ = new ::aggregator::CollectRuleResponse;
  return collectrule_response_;
}
inline ::aggregator::CollectRuleResponse* AggregatorResponse::release_collectrule_response() {
  clear_has_collectrule_response();
  ::aggregator::CollectRuleResponse* temp = collectrule_response_;
  collectrule_response_ = NULL;
  return temp;
}

// optional .aggregator.FileResponse file_response = 13;
inline bool AggregatorResponse::has_file_response() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AggregatorResponse::set_has_file_response() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AggregatorResponse::clear_has_file_response() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AggregatorResponse::clear_file_response() {
  if (file_response_ != NULL) file_response_->::aggregator::FileResponse::Clear();
  clear_has_file_response();
}
inline const ::aggregator::FileResponse& AggregatorResponse::file_response() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return file_response_ != NULL ? *file_response_ : *default_instance().file_response_;
#else
  return file_response_ != NULL ? *file_response_ : *default_instance_->file_response_;
#endif
}
inline ::aggregator::FileResponse* AggregatorResponse::mutable_file_response() {
  set_has_file_response();
  if (file_response_ == NULL) file_response_ = new ::aggregator::FileResponse;
  return file_response_;
}
inline ::aggregator::FileResponse* AggregatorResponse::release_file_response() {
  clear_has_file_response();
  ::aggregator::FileResponse* temp = file_response_;
  file_response_ = NULL;
  return temp;
}

// optional .aggregator.FileDataResponse filedata_response = 14;
inline bool AggregatorResponse::has_filedata_response() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AggregatorResponse::set_has_filedata_response() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AggregatorResponse::clear_has_filedata_response() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AggregatorResponse::clear_filedata_response() {
  if (filedata_response_ != NULL) filedata_response_->::aggregator::FileDataResponse::Clear();
  clear_has_filedata_response();
}
inline const ::aggregator::FileDataResponse& AggregatorResponse::filedata_response() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return filedata_response_ != NULL ? *filedata_response_ : *default_instance().filedata_response_;
#else
  return filedata_response_ != NULL ? *filedata_response_ : *default_instance_->filedata_response_;
#endif
}
inline ::aggregator::FileDataResponse* AggregatorResponse::mutable_filedata_response() {
  set_has_filedata_response();
  if (filedata_response_ == NULL) filedata_response_ = new ::aggregator::FileDataResponse;
  return filedata_response_;
}
inline ::aggregator::FileDataResponse* AggregatorResponse::release_filedata_response() {
  clear_has_filedata_response();
  ::aggregator::FileDataResponse* temp = filedata_response_;
  filedata_response_ = NULL;
  return temp;
}

// optional .aggregator.CheckSumResponse checksum_response = 15;
inline bool AggregatorResponse::has_checksum_response() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AggregatorResponse::set_has_checksum_response() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AggregatorResponse::clear_has_checksum_response() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AggregatorResponse::clear_checksum_response() {
  if (checksum_response_ != NULL) checksum_response_->::aggregator::CheckSumResponse::Clear();
  clear_has_checksum_response();
}
inline const ::aggregator::CheckSumResponse& AggregatorResponse::checksum_response() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return checksum_response_ != NULL ? *checksum_response_ : *default_instance().checksum_response_;
#else
  return checksum_response_ != NULL ? *checksum_response_ : *default_instance_->checksum_response_;
#endif
}
inline ::aggregator::CheckSumResponse* AggregatorResponse::mutable_checksum_response() {
  set_has_checksum_response();
  if (checksum_response_ == NULL) checksum_response_ = new ::aggregator::CheckSumResponse;
  return checksum_response_;
}
inline ::aggregator::CheckSumResponse* AggregatorResponse::release_checksum_response() {
  clear_has_checksum_response();
  ::aggregator::CheckSumResponse* temp = checksum_response_;
  checksum_response_ = NULL;
  return temp;
}

// optional .aggregator.InstructResponse instruct_response = 16;
inline bool AggregatorResponse::has_instruct_response() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AggregatorResponse::set_has_instruct_response() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AggregatorResponse::clear_has_instruct_response() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AggregatorResponse::clear_instruct_response() {
  if (instruct_response_ != NULL) instruct_response_->::aggregator::InstructResponse::Clear();
  clear_has_instruct_response();
}
inline const ::aggregator::InstructResponse& AggregatorResponse::instruct_response() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return instruct_response_ != NULL ? *instruct_response_ : *default_instance().instruct_response_;
#else
  return instruct_response_ != NULL ? *instruct_response_ : *default_instance_->instruct_response_;
#endif
}
inline ::aggregator::InstructResponse* AggregatorResponse::mutable_instruct_response() {
  set_has_instruct_response();
  if (instruct_response_ == NULL) instruct_response_ = new ::aggregator::InstructResponse;
  return instruct_response_;
}
inline ::aggregator::InstructResponse* AggregatorResponse::release_instruct_response() {
  clear_has_instruct_response();
  ::aggregator::InstructResponse* temp = instruct_response_;
  instruct_response_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace aggregator

// @@protoc_insertion_point(global_scope)

#ifdef _MSC_VER
# pragma warning(default: 4244 4127)
# pragma warning(pop)
#endif /* _MSC_VER */
#endif  // PROTOBUF_aggregator_2eproto__INCLUDED
